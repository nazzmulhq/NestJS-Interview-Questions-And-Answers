# NestJS ইন্টারভিউ প্রশ্ন ও উত্তর (বাংলা)

> NestJS ইন্টারভিউ প্রশ্ন এবং উত্তর রিপোজিটরিতে স্বাগতম!

-   এই রিপোজিটরি NestJS ডেভেলপারদের ইন্টারভিউর জন্য প্রস্তুতি নিতে একটি সম্পূর্ণ রিসোর্স হিসেবে কাজ করার লক্ষ্য রাখে। আপনি একজন শিক্ষানবিশ বা অভিজ্ঞ ডেভেলপার হোন না কেন, এই প্রশ্ন এবং উত্তরের সংগ্রহটি আপনার NestJS জ্ঞান ঝালাই করতে এবং ইন্টারভিউতে সফল হতে সাহায্য করার জন্য ডিজাইন করা হয়েছে।
    > প্রজেক্টটি পছন্দ হলে ⭐ ক্লিক করুন এবং যদি আপনি এই প্রজেক্টে অবদান রাখতে আগ্রহী হন। অবদান রাখার আগে, আমাদের নির্দেশিকা পর্যালোচনা করতে একটু সময় নিন।

## গুরুত্বপূর্ণ লিঙ্ক

-   [আচরণবিধি](./CODE_OF_CONDUCT.md): আমি আশা করি এই প্রজেক্টে অংশগ্রহণকারী সবাই আচরণবিধি অনুসরণ করবেন। নিশ্চিত করুন যে আপনি এই নির্দেশিকাগুলি বুঝেছেন এবং মেনে চলছেন।

-   [অবদান নির্দেশিকা](./CONTRIBUTING.md): অবদান রাখার আগে, অনুগ্রহ করে অবদান নির্দেশিকা পড়ুন। এগুলি কীভাবে প্রশ্ন জমা দিতে হয়, সমস্যা রিপোর্ট করতে হয় এবং আরও অনেক কিছু সম্পর্কে তথ্য সরবরাহ করে।

> আমাকে অনুসরণ করুন [@gasangw](https://github.com/gasangw).

### সূচিপত্র

| নং  | প্রশ্ন                                                                                                                                                                                                                                                                                                                                                                                    |
| --- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ১   | [NestJS কি?](#nestjs-কি)                                                                                                                                                                                                                                                                                                                                                                  |
| ২   | [কে NestJS ডেভেলপ করেছেন? কেন তারা NestJS ডেভেলপ করেছেন?](#কে-nestjs-ডেভেলপ-করেছেন-কেন-তারা-nestjs-ডেভেলপ-করেছেন)                                                                                                                                                                                                                                                                         |
| ৩   | [NestJS প্রথম কবে রিলিজ হয়েছিল?](#nestjs-প্রথম-কবে-রিলিজ-হয়েছিল)                                                                                                                                                                                                                                                                                                                        |
| ৪   | [আপনি কীভাবে NestJS ইনস্টল করতে এবং আপনার মেশিনে একটি নতুন প্রজেক্ট সেটআপ করতে পারেন?](#আপনি-কীভাবে-nestjs-ইনস্টল-করতে-এবং-আপনার-মেশিনে-একটি-নতুন-প্রজেক্ট-সেটআপ-করতে-পারেন)                                                                                                                                                                                                              |
| ৫   | [NestJS এবং Angular এর মধ্যে পার্থক্য কি?](#nestjs-এবং-angular-এর-মধ্যে-পার্থক্য-কি)                                                                                                                                                                                                                                                                                                      |
| ৬   | [NestJS এর সাথে C++, Ruby বা Python এর মতো অন্যান্য ভাষা ব্যবহার করা কি সম্ভব? যদি হ্যাঁ, তাহলে কিভাবে?](#nestjs-এর-সাথে-c-ruby-বা-python-এর-মতো-অন্যান্য-ভাষা-ব্যবহার-করা-কি-সম্ভব-যদি-হ্যাঁ-তাহলে-কিভাবে)                                                                                                                                                                               |
| ৭   | [একটি NestJS অ্যাপ্লিকেশনের প্রধান উপাদানগুলি কি কি?](#একটি-nestjs-অ্যাপ্লিকেশনের-প্রধান-উপাদানগুলি-কি-কি)                                                                                                                                                                                                                                                                                |
| ৮   | [Nest.js এ একটি ক্লাসকে কন্ট্রোলার হিসাবে কিভাবে ঘোষণা করবেন](#nestjs-এ-একটি-ক্লাসকে-কন্ট্রোলার-হিসাবে-কিভাবে-ঘোষণা-করবেন)                                                                                                                                                                                                                                                                |
| ৯   | [আপনি কি একটি NestJS কন্ট্রোলারে ডেকোরেটর ব্যবহার করার ব্যাখ্যা করতে পারেন?](#আপনি-কি-একটি-nestjs-কন্ট্রোলারে-ডেকোরেটর-ব্যবহার-করার-ব্যাখ্যা-করতে-পারেন)                                                                                                                                                                                                                                  |
| ১০  | [আপনি কিভাবে একটি NestJS কন্ট্রোলারে রাউট প্যারামিটার ব্যবহার করতে পারেন?](#আপনি-কিভাবে-একটি-nestjs-কন্ট্রোলারে-রাউট-প্যারামিটার-ব্যবহার-করতে-পারেন)                                                                                                                                                                                                                                      |
| ১১  | [`@Body()` ডেকোরেটরের ভূমিকা কি?](#body-ডেকোরেটরের-ভূমিকা-কি)                                                                                                                                                                                                                                                                                                                             |
| ১২  | [NestJS এর প্রেক্ষাপটে ইন্টারসেপ্টর কি?](#nestjs-এর-প্রেক্ষাপটে-ইন্টারসেপ্টর-কি)                                                                                                                                                                                                                                                                                                          |
| ১৩  | [NestJS এর প্রেক্ষাপটে পাইপ কি?](#nestjs-এর-প্রেক্ষাপটে-পাইপ-কি)                                                                                                                                                                                                                                                                                                                          |
| ১৪  | [NestJS এর প্রেক্ষাপটে গার্ড কি?](#nestjs-এর-প্রেক্ষাপটে-গার্ড-কি)                                                                                                                                                                                                                                                                                                                        |
| ১৫  | [NestJS এর প্রেক্ষাপটে মিডলওয়্যার কি?](#nestjs-এর-প্রেক্ষাপটে-মিডলওয়্যার-কি)                                                                                                                                                                                                                                                                                                            |
| ১৬  | [NestJS এ ডিপেন্ডেন্সি ইনজেকশন ধারণাটি ব্যাখ্যা করুন। এটি কীভাবে মডুলার এবং টেস্টেবল অ্যাপ্লিকেশন তৈরিতে সাহায্য করে?](#nestjs-এ-ডিপেন্ডেন্সি-ইনজেকশন-ধারণাটি-ব্যাখ্যা-করুন-এটি-কীভাবে-মডুলার-এবং-টেস্টেবল-অ্যাপ্লিকেশন-তৈরিতে-সাহায্য-করে)                                                                                                                                               |
| ১৭  | [`@Injectable()` এবং `@Inject()` ডেকোরেটরের মধ্যে পার্থক্য কি?](#injectable-এবং-inject-ডেকোরেটরের-মধ্যে-পার্থক্য-কি)                                                                                                                                                                                                                                                                      |
| ১৮  | [Nest logger স্ট্যান্ডার্ড console.log() থেকে কিভাবে আলাদা এবং আপনি কখন একটিকে অন্যটির উপর পছন্দ করবেন?](#nest-logger-স্ট্যান্ডার্ড-consolelog-থেকে-কিভাবে-আলাদা-এবং-আপনি-কখন-একটিকে-অন্যটির-উপর-পছন্দ-করবেন)                                                                                                                                                                             |
| ১৯  | [ইন্টারসেপ্টর এবং মিডলওয়্যারের মধ্যে পার্থক্য কি?](#ইন্টারসেপ্টর-এবং-মিডলওয়্যারের-মধ্যে-পার্থক্য-কি)                                                                                                                                                                                                                                                                                    |
| ২০  | [কোন টেস্টিং ফ্রেমওয়ার্ক NestJS এর সাথে সেরা কাজ করে?](#কোন-টেস্টিং-ফ্রেমওয়ার্ক-nestjs-এর-সাথে-সেরা-কাজ-করে)                                                                                                                                                                                                                                                                            |
| ২১  | [NestJS এ DTOs (Data Transfer Objects) এর উদ্দেশ্য ব্যাখ্যা করুন।](#nestjs-এ-dtos-data-transfer-objects-এর-উদ্দেশ্য-ব্যাখ্যা-করুন)                                                                                                                                                                                                                                                        |
| ২২  | [আপনি কিভাবে NestJS এ অ্যাসিঙ্ক্রোনাস অপারেশন হ্যান্ডেল করতে পারেন এবং Promise অবজেক্টের ভূমিকা কি?](#আপনি-কিভাবে-nestjs-এ-অ্যাসিঙ্ক্রোনাস-অপারেশন-হ্যান্ডেল-করতে-পারেন-এবং-promise-অবজেক্টের-ভূমিকা-কি)                                                                                                                                                                                  |
| ২৩  | [NestJS এ `@InjectRepository()` ডেকোরেটরের উদ্দেশ্য ব্যাখ্যা করুন।](#nestjs-এ-injectrepository-ডেকোরেটরের-উদ্দেশ্য-ব্যাখ্যা-করুন)                                                                                                                                                                                                                                                         |
| ২৪  | [NestJS এ `@nestjs/jwt` প্যাকেজের উদ্দেশ্য ব্যাখ্যা করুন?](#nestjs-এ-nestjsjwt-প্যাকেজের-উদ্দেশ্য-ব্যাখ্যা-করুন)                                                                                                                                                                                                                                                                          |
| ২৫  | [একটি API তে অনুমোদনের জন্য টোকেন কিভাবে ব্যবহৃত হয় তা আলোচনা করুন। অথেন্টিকেশন এবং অথরাইজেশনের মধ্যে পার্থক্য কি এবং টোকেন দিয়ে এই প্রক্রিয়াগুলি কীভাবে বাস্তবায়িত হয়?](#একটি-api-তে-অনুমোদনের-জন্য-টোকেন-কিভাবে-ব্যবহৃত-হয়-তা-আলোচনা-করুন-অথেন্টিকেশন-এবং-অথরাইজেশনের-মধ্যে-পার্থক্য-কি-এবং-টোকেন-দিয়ে-এই-প্রক্রিয়াগুলি-কীভাবে-বাস্তবায়িত-হয়)                                 |
| ২৬  | [টোকেনের জন্য একটি মেয়াদ শেষ হওয়ার সময় থাকা কেন গুরুত্বপূর্ণ? আপনি কীভাবে NestJS এ টোকেন মেয়াদ শেষ প্রয়োগ করতে পারেন এবং ব্যবহারকারী সেশন বজায় রাখতে রিফ্রেশ টোকেন কী ভূমিকা পালন করে?](#টোকেনের-জন্য-একটি-মেয়াদ-শেষ-হওয়ার-সময়-থাকা-কেন-গুরুত্বপূর্ণ-আপনি-কীভাবে-nestjs-এ-টোকেন-মেয়াদ-শেষ-প্রয়োগ-করতে-পারেন-এবং-ব্যবহারকারী-সেশন-বজায়-রাখতে-রিফ্রেশ-টোকেন-কী-ভূমিকা-পালন-করে) |
| ২৭  | [NestJS এ টোকেন রিফ্রেশের প্রক্রিয়া বর্ণনা করুন। ব্যবহারকারী সেশন বজায় রাখতে আপনি কীভাবে একটি স্বয়ংক্রিয় টোকেন রিফ্রেশ কৌশল প্রয়োগ করতে পারেন?](#nestjs-এ-টোকেন-রিফ্রেশের-প্রক্রিয়া-বর্ণনা-করুন-ব্যবহারকারী-সেশন-বজায়-রাখতে-আপনি-কীভাবে-একটি-স্বয়ংক্রিয়-টোকেন-রিফ্রেশ-কৌশল-প্রয়োগ-করতে-পারেন)                                                                                   |
| ২৮  | [NestJS কিভাবে অথেন্টিকেশন এবং অথরাইজেশন সমর্থন করে?](#nestjs-কিভাবে-অথেন্টিকেশন-এবং-অথরাইজেশন-সমর্থন-করে)                                                                                                                                                                                                                                                                                |
| ২৯  | [Nestjs এ Provider এবং Services এর মধ্যে পার্থক্য কি, আমরা কি injectable ডেকোরেটর ছাড়া একটি provider রাখতে পারি, উদাহরণ দিন?](#nestjs-এ-provider-এবং-services-এর-মধ্যে-পার্থক্য-কি-আমরা-কি-injectable-ডেকোরেটর-ছাড়া-একটি-provider-রাখতে-পারি-উদাহরণ-দিন)                                                                                                                                |
| ৩০  | [কাস্টম প্রোভাইডার কি এবং তারা Nest.js এ স্ট্যান্ডার্ড প্রোভাইডার থেকে কিভাবে আলাদা?](#কাস্টম-প্রোভাইডার-কি-এবং-তারা-nestjs-এ-স্ট্যান্ডার্ড-প্রোভাইডার-থেকে-কিভাবে-আলাদা)                                                                                                                                                                                                                 |
| ৩১  | [আপনি NestJS এ Swagger ব্যবহার করে কিভাবে API ডকুমেন্টেশন জেনারেট করতে পারেন? আপনার API ডকুমেন্ট করার গুরুত্ব এবং এটি ডেভেলপারদের কীভাবে সুবিধা দেয় তা আলোচনা করুন?](#আপনি-nestjs-এ-swagger-ব্যবহার-করে-কিভাবে-api-ডকুমেন্টেশন-জেনারেট-করতে-পারেন-আপনার-api-ডকুমেন্ট-করার-গুরুত্ব-এবং-এটি-ডেভেলপারদের-কীভাবে-সুবিধা-দেয়-তা-আলোচনা-করুন)                                                 |
| ৩২  | [`@nestjs/swagger ApiProperty()`, `ApiOperation()` ডেকোরেটরের উদ্দেশ্য ব্যাখ্যা করুন?](#nestjsswagger-apiproperty-apioperation-ডেকোরেটরের-উদ্দেশ্য-ব্যাখ্যা-করুন)                                                                                                                                                                                                                         |
| ৩৩  | [একটি NestJS অ্যাপ্লিকেশনে Dockerfile এর উদ্দেশ্য ব্যাখ্যা করুন এবং এটি কন্টেইনারাইজেশনকে কীভাবে সহজতর করে?](#একটি-nestjs-অ্যাপ্লিকেশনে-dockerfile-এর-উদ্দেশ্য-ব্যাখ্যা-করুন-এবং-এটি-কন্টেইনারাইজেশনকে-কীভাবে-সহজতর-করে)                                                                                                                                                                  |
| ৩৪  | [আপনি NestJS এর সাথে Docker Compose কিভাবে ব্যবহার করতে পারেন এবং একটি মাল্টি-কন্টেইনার সেটআপে এর ভূমিকা কি?](#আপনি-nestjs-এর-সাথে-docker-compose-কিভাবে-ব্যবহার-করতে-পারেন-এবং-একটি-মাল্টি-কন্টেইনার-সেটআপে-এর-ভূমিকা-কি)                                                                                                                                                                |
| ৩৫  | [`@nestjs/passport` প্যাকেজের উদ্দেশ্য কি এবং এটি NestJS এ অথেন্টিকেশনকে কীভাবে সহজতর করে?](#nestjspassport-প্যাকেজের-উদ্দেশ্য-কি-এবং-এটি-nestjs-এ-অথেন্টিকেশনকে-কীভাবে-সহজতর-করে)                                                                                                                                                                                                        |
| ৩৬  | [আপনি NestJS এ ফাইল আপলোড কিভাবে হ্যান্ডেল করতে পারেন এবং Multer লাইব্রেরির ভূমিকা কি?](#আপনি-nestjs-এ-ফাইল-আপলোড-কিভাবে-হ্যান্ডেল-করতে-পারেন-এবং-multer-লাইব্রেরির-ভূমিকা-কি)                                                                                                                                                                                                            |
| ৩৭  | [NestJS কিভাবে ডেটাবেস ইন্টারঅ্যাকশন হ্যান্ডেল করে এবং সমর্থিত ডেটাবেসগুলি কি কি?](#nestjs-কিভাবে-ডেটাবেস-ইন্টারঅ্যাকশন-হ্যান্ডেল-করে-এবং-সমর্থিত-ডেটাবেসগুলি-কি-কি)                                                                                                                                                                                                                      |
| ৩৮  | [Nestjs এ সার্কুলার ডিপেন্ডেন্সি (dependency cycle) কি এবং তারা কিভাবে ঠিক করা যায়?](#nestjs-এ-সার্কুলার-ডিপেন্ডেন্সি-dependency-cycle-কি-এবং-তারা-কিভাবে-ঠিক-করা-যায়)                                                                                                                                                                                                                  |
| ৩৯  | [আপনি NestJS এ ত্রুটি কিভাবে হ্যান্ডেল করতে পারেন?](#আপনি-nestjs-এ-ত্রুটি-কিভাবে-হ্যান্ডেল-করতে-পারেন)                                                                                                                                                                                                                                                                                    |
| ৪০  | [NestJS কিভাবে CORS (Cross-Origin Resource Sharing) হ্যান্ডেল করে?](#nestjs-কিভাবে-cors-cross-origin-resource-sharing-হ্যান্ডেল-করে)                                                                                                                                                                                                                                                      |
| ৪১  | [NestJS মিডলওয়্যারে ExecutionContext এর উদ্দেশ্য ব্যাখ্যা করুন?](#nestjs-মিডলওয়্যারে-executioncontext-এর-উদ্দেশ্য-ব্যাখ্যা-করুন)                                                                                                                                                                                                                                                        |
| ৪২  | [আপনি TypeORM ব্যবহার করে NestJS এ সফট ডিলিট কিভাবে প্রয়োগ করতে পারেন এবং হার্ড ডিলিটের উপর সফট ডিলিট কেন পছন্দ করা যেতে পারে?](#আপনি-typeorm-ব্যবহার-করে-nestjs-এ-সফট-ডিলিট-কিভাবে-প্রয়োগ-করতে-পারেন-এবং-হার্ড-ডিলিটের-উপর-সফট-ডিলিট-কেন-পছন্দ-করা-যেতে-পারে)                                                                                                                          |
| ৪৩  | [NestJS এ এনভায়রনমেন্ট ভ্যারিয়েবলের ধারণাটি ব্যাখ্যা করুন এবং কনফিগারেশন ম্যানেজমেন্টের জন্য সেগুলি কীভাবে ব্যবহার করা যায়?](#nestjs-এ-এনভায়রনমেন্ট-ভ্যারিয়েবলের-ধারণাটি-ব্যাখ্যা-করুন-এবং-কনফিগারেশন-ম্যানেজমেন্টের-জন্য-সেগুলি-কীভাবে-ব্যবহার-করা-যায়)                                                                                                                            |
| ৪৪  | [TypeORM এ মাইগ্রেশন স্ক্রিপ্টের ভূমিকা কি এবং আপনি কীভাবে একটি NestJS অ্যাপ্লিকেশনে মাইগ্রেশন তৈরি এবং চালাতে পারেন?](#typeorm-এ-মাইগ্রেশন-স্ক্রিপ্টের-ভূমিকা-কি-এবং-আপনি-কীভাবে-একটি-nestjs-অ্যাপ্লিকেশনে-মাইগ্রেশন-তৈরি-এবং-চালাতে-পারেন)                                                                                                                                              |
| ৪৫  | [NestJS এ ExecutionContext এর উদ্দেশ্য কি?](#nestjs-এ-executioncontext-এর-উদ্দেশ্য-কি)                                                                                                                                                                                                                                                                                                    |
| ৪৬  | [NestJS কন্ট্রোলারে `@Res()` ডেকোরেটরের উদ্দেশ্য কি?](#nestjs-কন্ট্রোলারে-res-ডেকোরেটরের-উদ্দেশ্য-কি)                                                                                                                                                                                                                                                                                     |
| ৪৭  | [NestJS এ বিভিন্ন মডুল ব্যাখ্যা করুন?](#nestjs-এ-বিভিন্ন-মডুল-ব্যাখ্যা-করুন)                                                                                                                                                                                                                                                                                                              |
| ৪৮  | [আপনি কিভাবে আপনার NestJS অ্যাপ্লিকেশন সুরক্ষিত করতে পারেন?](#আপনি-কিভাবে-আপনার-nestjs-অ্যাপ্লিকেশন-সুরক্ষিত-করতে-পারেন)                                                                                                                                                                                                                                                                  |
| ৪৯  | [NestJS অ্যাপ্লিকেশনের এন্ট্রি ফাইল কি?](#nestjs-অ্যাপ্লিকেশনের-এন্ট্রি-ফাইল-কি)                                                                                                                                                                                                                                                                                                          |
| ৫০  | [ডিপেন্ডেন্সি ইনজেকশন এবং ইনভার্সন অফ কন্ট্রোল (IoC) এর মধ্যে পার্থক্য কি?](#ডিপেন্ডেন্সি-ইনজেকশন-এবং-ইনভার্সন-অফ-কন্ট্রোল-ioc-এর-মধ্যে-পার্থক্য-কি)                                                                                                                                                                                                                                      |
| ৫১  | [আপনি NestJS এ ক্যাশিং কিভাবে প্রয়োগ করতে পারেন?](#আপনি-nestjs-এ-ক্যাশিং-কিভাবে-প্রয়োগ-করতে-পারেন)                                                                                                                                                                                                                                                                                      |
| ৫২  | [NestJS এ ডিপেন্ডেন্সি ইনভার্সন প্রিন্সিপাল (DIP) এর উদ্দেশ্য ব্যাখ্যা করুন?](#nestjs-এ-ডিপেন্ডেন্সি-ইনভার্সন-প্রিন্সিপাল-dip-এর-উদ্দেশ্য-ব্যাখ্যা-করুন)                                                                                                                                                                                                                                  |
| ৫৩  | [আপনি NestJS এ টাস্ক শিডিউল কিভাবে করতে পারেন?](#আপনি-nestjs-এ-টাস্ক-শিডিউল-কিভাবে-করতে-পারেন)                                                                                                                                                                                                                                                                                            |
| ৫৪  | [আপনি NestJS এ ডেটাবেস ট্রানজেকশন কিভাবে হ্যান্ডেল করতে পারেন এবং নির্দিষ্ট পরিস্থিতিতে ট্রানজেকশন কেন গুরুত্বপূর্ণ?](#আপনি-nestjs-এ-ডেটাবেস-ট্রানজেকশন-কিভাবে-হ্যান্ডেল-করতে-পারেন-এবং-নির্দিষ্ট-পরিস্থিতিতে-ট্রানজেকশন-কেন-গুরুত্বপূর্ণ)                                                                                                                                                |
| ৫৫  | [আপনি NestJS APIs এ ভার্সনিং কিভাবে প্রয়োগ করতে পারেন?](#আপনি-nestjs-apis-এ-ভার্সনিং-কিভাবে-প্রয়োগ-করতে-পারেন)                                                                                                                                                                                                                                                                          |
| ৫৬  | [`@nestjs/graphql Resolver` এবং `@nestjs/graphql Scalar` ডেকোরেটরের উদ্দেশ্য ব্যাখ্যা করুন এবং তারা NestJS এ GraphQL এর সাথে কীভাবে সম্পর্কিত?](#nestjsgraphql-resolver-এবং-nestjsgraphql-scalar-ডেকোরেটরের-উদ্দেশ্য-ব্যাখ্যা-করুন-এবং-তারা-nestjs-এ-graphql-এর-সাথে-কীভাবে-সম্পর্কিত)                                                                                                    |
| ৫৭  | [NestJS এ সিরিয়ালাইজেশন এবং ডিসিরিয়ালাইজেশনের ধারণা ব্যাখ্যা করুন?](#nestjs-এ-সিরিয়ালাইজেশন-এবং-ডিসিরিয়ালাইজেশনের-ধারণা-ব্যাখ্যা-করুন)                                                                                                                                                                                                                                                |
| ৫৮  | [মাইক্রোসার্ভিসেসের প্রেক্ষাপটে NestJS মিডলওয়্যারের ভূমিকা ব্যাখ্যা করুন এবং একটি মাইক্রোসার্ভিসেস সেটআপে মিডলওয়্যার উপকারী এমন একটি পরিস্থিতি প্রদান করুন?](#মাইক্রোসার্ভিসেসের-প্রেক্ষাপটে-nestjs-মিডলওয়্যারের-ভূমিকা-ব্যাখ্যা-করুন-এবং-একটি-মাইক্রোসার্ভিসেস-সেটআপে-মিডলওয়্যার-উপকারী-এমন-একটি-পরিস্থিতি-প্রদান-করুন)                                                              |
| ৫৯  | [টাইট কাপলিং এবং লুস কাপলিং এর মতো বিভিন্ন ধরণের কাপলিং আলোচনা করুন এবং একটি মডুলারাইজড অ্যাপ্লিকেশনে লুস কাপলিং অর্জনে NestJS মডিউলগুলি কীভাবে অবদান রাখে তার উদাহরণ দিন?](#টাইট-কাপলিং-এবং-লুস-কাপলিং-এর-মতো-বিভিন্ন-ধরণের-কাপলিং-আলোচনা-করুন-এবং-একটি-মডুলারাইজড-অ্যাপ্লিকেশনে-লুস-কাপলিং-অর্জনে-nestjs-মডিউলগুলি-কীভাবে-অবদান-রাখে-তার-উদাহরণ-দিন)                                    |
| ৬০  | [NestJS কিভাবে Server-Sent Events (SSE) সমর্থন করে এবং ওয়েব অ্যাপ্লিকেশনে রিয়েল-টাইম যোগাযোগের জন্য SSE ব্যবহারের প্রাথমিক সুবিধাগুলি কি কি?](#nestjs-কিভাবে-server-sent-events-sse-সমর্থন-করে-এবং-ওয়েব-অ্যাপ্লিকেশনে-রিয়েল-টাইম-যোগাযোগের-জন্য-sse-ব্যবহারের-প্রাথমিক-সুবিধাগুলি-কি-কি)                                                                                              |

### উন্নত প্রশ্ন (৮ বছরের অভিজ্ঞতার জন্য)

| নং  | প্রশ্ন                                                                                                                                                                                                                       |
| --- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ৬১  | [কাস্টম প্রোভাইডার তৈরি করার বিভিন্ন উপায় কি কি? useClass, useValue, useFactory এবং useExisting ব্যাখ্যা করুন](#কাস্টম-প্রোভাইডার-তৈরি-করার-বিভিন্ন-উপায়-কি-কি-useclass-usevalue-usefactory-এবং-useexisting-ব্যাখ্যা-করুন) |
| ৬২  | [NestJS এ অপশনাল প্রোভাইডার কি এবং কিভাবে তারা ব্যবহৃত হয়?](#nestjs-এ-অপশনাল-প্রোভাইডার-কি-এবং-কিভাবে-তারা-ব্যবহৃত-হয়)                                                                                                     |
| ৬৩  | [প্রোপার্টি-ভিত্তিক ইনজেকশন কি এবং কন্সট্রাক্টর-ভিত্তিক ইনজেকশনের সাথে এর পার্থক্য কি?](#প্রোপার্টি-ভিত্তিক-ইনজেকশন-কি-এবং-কন্সট্রাক্টর-ভিত্তিক-ইনজেকশনের-সাথে-এর-পার্থক্য-কি)                                               |
| ৬৪  | [NestJS এ স্কোপড প্রোভাইডার কি? DEFAULT, REQUEST এবং TRANSIENT স্কোপ ব্যাখ্যা করুন](#nestjs-এ-স্কোপড-প্রোভাইডার-কি-default-request-এবং-transient-স্কোপ-ব্যাখ্যা-করুন)                                                        |
| ৬৫  | [হায়ারার্কিক্যাল ইনজেক্টর এবং মডিউল রেফারেন্স ব্যাখ্যা করুন](#হায়ারার্কিক্যাল-ইনজেক্টর-এবং-মডিউল-রেফারেন্স-ব্যাখ্যা-করুন)                                                                                                  |
| ৬৬  | [NestJS এ অ্যাসিঙ্ক্রোনাস প্রোভাইডার কিভাবে কাজ করে?](#nestjs-এ-অ্যাসিঙ্ক্রোনাস-প্রোভাইডার-কিভাবে-কাজ-করে)                                                                                                                   |
| ৬৭  | [ডায়নামিক মডিউলস এবং তাদের কনফিগারেশন সম্পর্কে বিস্তারিত ব্যাখ্যা করুন](#ডায়নামিক-মডিউলস-এবং-তাদের-কনফিগারেশন-সম্পর্কে-বিস্তারিত-ব্যাখ্যা-করুন)                                                                            |
| ৬৮  | [NestJS এ মাল্টি-টেন্যান্সি কিভাবে ইমপ্লিমেন্ট করবেন?](#nestjs-এ-মাল্টি-টেন্যান্সি-কিভাবে-ইমপ্লিমেন্ট-করবেন)                                                                                                                 |
| ৬৯  | [CQRS প্যাটার্ন এবং NestJS এ এর বাস্তবায়ন ব্যাখ্যা করুন](#cqrs-প্যাটার্ন-এবং-nestjs-এ-এর-বাস্তবায়ন-ব্যাখ্যা-করুন)                                                                                                          |
| ৭০  | [Event Sourcing কি এবং NestJS এ কিভাবে ব্যবহার করা হয়?](#event-sourcing-কি-এবং-nestjs-এ-কিভাবে-ব্যবহার-করা-হয়)                                                                                                             |

### উত্তর

## ১. NestJS কি?

Nest (NestJS) হল দক্ষ, স্কেলেবল Node.js সার্ভার সাইড অ্যাপ্লিকেশন তৈরি করার জন্য একটি ফ্রেমওয়ার্ক। এটি প্রগতিশীল JavaScript ব্যবহার করে এবং TypeScript দিয়ে নির্মিত এবং সম্পূর্ণভাবে TypeScript সমর্থন করে।

## ২. কে NestJS ডেভেলপ করেছেন? কেন তারা NestJS ডেভেলপ করেছেন?

NestJS ডেভেলপ করেছেন Kamil Myśliwiec, যিনি একজন পোলিশ সফটওয়্যার ইঞ্জিনিয়ার। তিনি NestJS ডেভেলপ করেছেন Node.js অ্যাপ্লিকেশনে সামঞ্জস্যপূর্ণ কাঠামোর অভাব দূর করতে এবং Angular এর মতো ফ্রেমওয়ার্কের শক্তিশালী বৈশিষ্ট্যগুলি সার্ভার-সাইডে নিয়ে আসতে।

## ৩. NestJS প্রথম কবে রিলিজ হয়েছিল?

NestJS প্রথম রিলিজ হয়েছিল ৫ অক্টোবর, ২০১৬ তারিখে।

## ৪. আপনি কীভাবে NestJS ইনস্টল করতে এবং আপনার মেশিনে একটি নতুন প্রজেক্ট সেটআপ করতে পারেন?

আপনার মেশিনে NestJS ইনস্টল করতে, আপনার Node.js এবং npm (Node Package Manager) ইনস্টল করা থাকতে হবে। একবার সেগুলো থাকলে, আপনি নিম্নলিখিত কমান্ড ব্যবহার করে আপনার মেশিনে NestJS CLI (Command Line Interface) গ্লোবালি ইনস্টল করতে পারেন:

```javascript
$ npm i -g @nestjs/cli
```

এই কমান্ডটি `NestJS CLI` গ্লোবালি ইনস্টল করে, যা আপনাকে আপনার মেশিনের যেকোনো স্থান থেকে nest কমান্ড ব্যবহার করতে দেয়। NestJS CLI দিয়ে, আপনি নতুন প্রজেক্ট তৈরি করতে পারেন:

```javascript
$ nest new project-name
```

এবং একটি প্রজেক্ট তৈরি করার পরে আপনি NestJS মডিউল, সার্ভিস ইত্যাদি জেনারেট করতে পারেন।

```javascript
$ nest generate module users
```

চালনা করা

```javascript
$ nest g resource users
```

এটি একটি নির্দিষ্ট এনটিটির জন্য CRUD (Create, Read, Update, Delete) অপারেশন পরিচালনা করতে একসাথে কাজ করে এমন বেশ কয়েকটি ফাইল তৈরি করবে, এই ক্ষেত্রে, "users"। এটি জেনারেট করবে:

একটি `controller` HTTP রিকোয়েস্ট পরিচালনার জন্য (যেমন, users.controller.ts)

একটি `service` ব্যবসায়িক লজিকের জন্য (যেমন, users.service.ts)

একটি `module` রিসোর্স এনক্যাপসুলেট করার জন্য (যেমন, users.module.ts)

আপনি যদি REST API জেনারেট করতে চান, তাহলে এটি ইনপুট ডেটা পরিচালনার জন্য `DTO` (Data Transfer Object) ক্লাস তৈরি করবে (যেমন, `create-user.dto.ts, update-user.dto.ts`)

আপনি যদি GraphQL API জেনারেট করতে চান, তাহলে এটি একটি resolver তৈরি করবে (যেমন, `users.resolver.ts`)

## ৫. NestJS এবং Angular এর মধ্যে পার্থক্য কি?

Angular হল ক্লায়েন্ট-সাইড অ্যাপ্লিকেশন তৈরির জন্য একটি ফ্রেমওয়ার্ক এবং এটি কম্পোনেন্ট, মডিউল, সার্ভিস ইত্যাদি ব্যবহার করে আপনার ফ্রন্টএন্ড কোড সংগঠিত করার একটি উপায় প্রদান করে।

অন্যদিকে NestJS হল সার্ভার-সাইড অ্যাপ্লিকেশন তৈরির জন্য একটি ফ্রেমওয়ার্ক। NestJS TypeScript এবং Express এর উপরে নির্মিত, এবং এটি এন্টারপ্রাইজ-লেভেল অ্যাপ্লিকেশনের জন্য আরো শক্তিশালী এবং স্কেলেবল আর্কিটেকচার প্রদান করার লক্ষ্য রাখে। তবে এটি Angular দ্বারা অনুপ্রাণিত এবং মডিউল, ডেকোরেটর এবং ডিপেন্ডেন্সি ইনজেকশনের মতো অনুরূপ ধারণা শেয়ার করে।

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬. NestJS এর সাথে C++, Ruby বা Python এর মতো অন্যান্য ভাষা ব্যবহার করা কি সম্ভব? যদি হ্যাঁ, তাহলে কিভাবে?

হ্যাঁ, NestJS এর সাথে অন্যান্য ভাষা ব্যবহার করা সম্ভব। NestJS ভাষা নিরপেক্ষ, যার মানে এটি যেকোনো ভাষার সাথে কাজ করতে পারে যা JavaScript-এ কম্পাইল হতে পারে।

Python, Ruby বা অন্যান্য ভাষার ক্ষেত্রে, সেগুলো সরাসরি NestJS এর সাথে ব্যবহার করা যায় না কারণ NestJS Node.js রানটাইমের উপর নির্ভর করে, যা JavaScript এক্সিকিউট করে।

তবে, আপনি অবশ্যই Python, Ruby বা অন্য যেকোনো ভাষায় আলাদা সার্ভিস তৈরি করতে পারেন এবং HTTP, gRPC বা অন্য যেকোনো কমিউনিকেশন প্রোটোকলের মাধ্যমে আপনার NestJS অ্যাপ্লিকেশনের সাথে যোগাযোগ করতে পারেন। এটি মাইক্রোসার্ভিসেস আর্কিটেকচারে একটি সাধারণ প্যাটার্ন।

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭. একটি NestJS অ্যাপ্লিকেশনের প্রধান উপাদানগুলি কি কি?

NestJS অ্যাপ্লিকেশনের প্রধান উপাদানগুলি অন্তর্ভুক্ত করে:

`Modules:` মডিউলগুলি সম্পর্কিত কম্পোনেন্টগুলিকে একটি একক ব্লকে সংগঠিত করার একটি উপায়। তারা আপনার অ্যাপ্লিকেশন স্ট্রাকচার করার একটি উপায় প্রদান করে।

`Controllers:` কন্ট্রোলাররা আগত `requests` পরিচালনা এবং ক্লায়েন্টে `responses` ফেরত দেওয়ার জন্য দায়ী। কন্ট্রোলাররা রুট সংগঠিত করে এবং সেই রুটগুলিতে আসা HTTP রিকোয়েস্ট পরিচালনা করে।

`Services:` সার্ভিসগুলি ব্যবসায়িক লজিক এবং ডেটা সোর্সের সাথে ইন্টারঅ্যাক্ট করার জন্য দায়ী। তারা কন্ট্রোলার বা অন্যান্য সার্ভিসে ইনজেক্ট করা যায়, কোড পুনর্ব্যবহারযোগ্যতা এবং উদ্বেগের বিচ্ছেদকে প্রচার করে।

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮. Nest.js এ একটি ক্লাসকে কন্ট্রোলার হিসাবে কিভাবে ঘোষণা করবেন?

Nest.js এ আমরা **@Controller()** ডেকোরেটর ব্যবহার করে একটি ক্লাসকে কন্ট্রোলার হিসাবে ঘোষণা করতে পারি। এখানে একটি মৌলিক উদাহরণ:

```javascript
import { Controller, Get } from "@nestjs/common";

@Controller("example")
class ExampleController {
	@Get()
	getHello(): string {
		return "Hello world!";
	}
}
```

এই উদাহরণে `ExampleController` হল একটি কন্ট্রোলার ক্লাস। **@Controller('example')** ডেকোরেটর Nest.js কে বলে যে এই ক্লাসটি একটি কন্ট্রোলার যা `example` রুটে রিকোয়েস্ট পরিচালনা করবে। `getHello` মেথডে **@Get()** ডেকোরেটর নির্দেশ করে যে এই মেথডটি HTTP GET রিকোয়েস্ট পরিচালনা করবে।

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৯. আপনি কি একটি NestJS কন্ট্রোলারে ডেকোরেটর ব্যবহার করার ব্যাখ্যা করতে পারেন?

ডেকোরেটর ব্যবহার কিভাবে করতে হয় তা ব্যাখ্যা করার আগে, আমাকে `decorators` সম্পর্কে আরো ব্যাখ্যা করতে দিন:

`decorators` হল বিশেষ ফাংশন যা একটি `@` চিহ্ন দিয়ে প্রিফিক্স করা হয় এবং ক্লাস, মেথড বা প্রপার্টির সাথে সংযুক্ত করা যায়। তারা মেটাডেটা, মেথড, প্রপার্টি যোগ করতে বা ক্লাস, মেথড বা প্রপার্টির আচরণ পর্যবেক্ষণ করতে ব্যবহৃত হয়।

NestJS বেশ কয়েকটি বিল্ট-ইন ডেকোরেটর প্রদান করে এবং আপনি কাস্টম ডেকোরেটরও তৈরি করতে পারেন। NestJS এ বিল্ট-ইন ডেকোরেটরের কিছু উদাহরণ:

1. `Class decorators` যেমন `@Controller()`, `@Module()`, `@Injectable()`, ইত্যাদি। এগুলো ক্লাস অ্যানোটেট করতে ব্যবহৃত হয়।

2. `Method decorators` যেমন `@Get()`, `@Post()`, `@Put()`, ইত্যাদি। এগুলো কন্ট্রোলার ক্লাসের মধ্যে নির্দিষ্ট রুট পরিচালনার জন্য মেথড অ্যানোটেট করতে ব্যবহৃত হয়।

3. `Parameter decorators` যেমন `@Req()`, `@Res()`, `@Body()`, ইত্যাদি। এগুলো রুট হ্যান্ডলিং মেথডের মধ্যে প্যারামিটার অ্যানোটেট করতে ব্যবহৃত হয়।

4. `Property decorators` যেমন `@Inject()`। এগুলো ক্লাসের মধ্যে প্রপার্টি অ্যানোটেট করতে ব্যবহৃত হয়।

5. `Custom decorators`। আপনি আপনার অ্যাপ্লিকেশন জুড়ে সাধারণ কাজ পরিচালনা করতে আপনার নিজস্ব ডেকোরেটর তৈরি করতে পারেন।

উদাহরণস্বরূপ, নিচে দেখানো হয়েছে কিভাবে `method decorators` ব্যবহার করে GET, POST, PUT, DELETE রিকোয়েস্ট পরিচালনা করা হয়:

```javascript
import { Controller, Get, Param, Body, Post, Patch, Delete } from "@nestjs/common";

@Controller("cats")
export class CatsController {
	@Get()
	findAll(): string {
		return "This action returns all cats";
	}

	@Get(":id")
	findOne(@Param("id") id: number): string {
		return `This action returns a cat with the provided id`;
	}

	@Post()
	create(@Body() body: any): string {
		return `This action returns the body of the cat`;
	}

	@Patch("id")
	update(@Param("id") id: number, @Body() body: any): string {
		return `This action updates the body of the cat`;
	}

	@Delete("id")
	remove(@Param("id") id: number): string {
		return `This action removes a cat`;
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১০. আপনি কিভাবে একটি NestJS কন্ট্রোলারে রাউট প্যারামিটার ব্যবহার করতে পারেন?

একটি NestJS কন্ট্রোলারে রাউট প্যারামিটার কন্ট্রোলার মেথডে `@Param()` ডেকোরেটর ব্যবহার করে অ্যাক্সেস করা যায়।

```javascript
@Patch('id')
update(@Param('id') id: number, @Body() body: any ): string {
   return `This action updates the body of the cat`;
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১১. `@Body()` ডেকোরেটরের ভূমিকা কি?

NestJS এ `@Body()` ডেকোরেটর আগত HTTP রিকোয়েস্টের সম্পূর্ণ বডি এক্সট্র্যাক্ট করতে ব্যবহৃত হয়। এটি সাধারণত POST এবং PUT রিকোয়েস্ট পরিচালনা করে এমন মেথডে ব্যবহৃত হয় যেখানে ডেটা রিকোয়েস্টের বডিতে পাঠানো হয়।

উদাহরণস্বরূপ, আপনার যদি আপনার কন্ট্রোলারে একটি নতুন ইউজার তৈরি করার জন্য একটি মেথড থাকে, আপনি রিকোয়েস্ট থেকে ইউজার ডেটা পেতে `@Body()` ডেকোরেটর ব্যবহার করতে পারেন:

```javascript
@Post()
create(@Body() createUserDto: CreateUserDto) {
  return this.usersService.create(createUserDto);
}
```

এই উদাহরণে, createUserDto হল একটি অবজেক্ট যা রিকোয়েস্ট বডিতে পাঠানো ডেটা ধারণ করে। @Body() ডেকোরেটর স্বয়ংক্রিয়ভাবে JSON রিকোয়েস্ট বডি পার্স করে এবং এটি createUserDto প্যারামিটারে অ্যাসাইন করে।

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১২. NestJS এর প্রেক্ষাপটে ইন্টারসেপ্টর কি?

একটি ইন্টারসেপ্টর হল `@Injectable()` ডেকোরেটর দিয়ে অ্যানোটেট করা ক্লাস যা `NestInterceptor` ইন্টারফেস ইমপ্লিমেন্ট করে।

```typescript
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from "@nestjs/common";
import { Observable } from "rxjs";
import { tap } from "rxjs/operators";

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
	intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
		console.log("রিকোয়েস্ট শুরু...");
		const now = Date.now();
		return next.handle().pipe(tap(() => console.log(`সময় লেগেছে: ${Date.now() - now}ms`)));
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১৩. NestJS এর প্রেক্ষাপটে পাইপ কি?

পাইপ হল `@Injectable()` ডেকোরেটর যুক্ত ক্লাস যা `PipeTransform` ইন্টারফেস ইমপ্লিমেন্ট করে। পাইপের দুটি প্রধান কাজ: ভ্যালিডেশন এবং ট্রান্সফরমেশন।

```typescript
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from "@nestjs/common";

@Injectable()
export class ParseIntPipe implements PipeTransform<string, number> {
	transform(value: string, metadata: ArgumentMetadata): number {
		const val = parseInt(value, 10);
		if (isNaN(val)) {
			throw new BadRequestException("ভ্যালিডেশন ব্যর্থ");
		}
		return val;
	}
}
```

**বিল্ট-ইন পাইপ:** ValidationPipe, ParseIntPipe, ParseFloatPipe, ParseBoolPipe, ParseArrayPipe, ParseUUIDPipe, ParseEnumPipe, DefaultValuePipe, ParseFilePipe

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১৪. NestJS এর প্রেক্ষাপটে গার্ড কি?

গার্ড হল `CanActivate` ইন্টারফেস ইমপ্লিমেন্ট করে এমন ক্লাস। গার্ড নির্ধারণ করে একটি রিকোয়েস্ট রুট হ্যান্ডলার দ্বারা পরিচালিত হবে কিনা।

```typescript
import { Injectable, CanActivate, ExecutionContext } from "@nestjs/common";

@Injectable()
export class AuthGuard implements CanActivate {
	canActivate(context: ExecutionContext): boolean {
		const request = context.switchToHttp().getRequest();
		return this.validateRequest(request);
	}

	private validateRequest(request: any): boolean {
		// অথেন্টিকেশন লজিক
		return !!request.headers.authorization;
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১৫. NestJS এর প্রেক্ষাপটে মিডলওয়্যার কি?

মিডলওয়্যার হল এমন ফাংশন যা রুট হ্যান্ডলারের আগে কল হয়। মিডলওয়্যারের request, response অবজেক্ট এবং next() ফাংশনে অ্যাক্সেস থাকে।

```typescript
import { Injectable, NestMiddleware } from "@nestjs/common";
import { Request, Response, NextFunction } from "express";

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
	use(req: Request, res: Response, next: NextFunction) {
		console.log(`${req.method} ${req.url}`);
		next();
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১৬. NestJS এ ডিপেন্ডেন্সি ইনজেকশন ধারণাটি ব্যাখ্যা করুন

ডিপেন্ডেন্সি ইনজেকশন (DI) এমন একটি ডিজাইন প্যাটার্ন যেখানে একটি ক্লাস তার ডিপেন্ডেন্সি নিজে তৈরি না করে বাহ্যিক উৎস থেকে গ্রহণ করে।

```typescript
// Service
@Injectable()
export class CatsService {
	findAll() {
		return ["cat1", "cat2"];
	}
}

// Controller এ ইনজেক্ট
@Controller("cats")
export class CatsController {
	constructor(private catsService: CatsService) {}

	@Get()
	findAll() {
		return this.catsService.findAll();
	}
}
```

**সুবিধা:** মডুলারিটি, টেস্টেবিলিটি, পুনর্ব্যবহারযোগ্যতা

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১৭. `@Injectable()` এবং `@Inject()` ডেকোরেটরের মধ্যে পার্থক্য কি?

`@Injectable()`: ক্লাসকে NestJS DI সিস্টেমে provider হিসেবে চিহ্নিত করে। Service ক্লাসে ব্যবহৃত হয়।

`@Inject()`: নির্দিষ্ট ডিপেন্ডেন্সি ইনজেক্ট করার জন্য ব্যবহৃত। কাস্টম প্রোভাইডারের জন্য প্রয়োজন।

```typescript
// @Injectable() - Service এ
@Injectable()
export class CatsService {}

// @Inject() - কাস্টম প্রোভাইডারের জন্য
@Injectable()
export class AppService {
	constructor(@Inject("CONFIG") private config: any) {}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১৮. Nest logger স্ট্যান্ডার্ড console.log() থেকে কিভাবে আলাদা?

NestJS Logger অতিরিক্ত ফিচার প্রদান করে:

-   **Log Levels:** log, error, warn, debug, verbose
-   **Context Information:** লগের উৎস ট্র্যাক করা
-   **Customization:** কাস্টম লগার তৈরি করা সম্ভব
-   **Production Ready:** স্ট্রাকচারড লগিং

```typescript
import { Logger } from "@nestjs/common";

@Injectable()
export class CatsService {
	private readonly logger = new Logger(CatsService.name);

	findAll() {
		this.logger.log("সব cats খোঁজা হচ্ছে");
		this.logger.debug("Debug তথ্য");
		this.logger.error("Error ঘটেছে");
		return [];
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ১৯. ইন্টারসেপ্টর এবং মিডলওয়্যারের মধ্যে পার্থক্য কি?

| বৈশিষ্ট্য             | Middleware        | Interceptor                    |
| --------------------- | ----------------- | ------------------------------ |
| Scope                 | HTTP only         | HTTP, WebSocket, Microservices |
| Access                | Request, Response | ExecutionContext               |
| Response Manipulation | Limited           | Full control                   |
| RxJS Support          | No                | Yes                            |

**Middleware:** শুধু HTTP রিকোয়েস্ট-রেসপন্স সাইকেলে কাজ করে

**Interceptor:** সব ট্রান্সপোর্টে কাজ করে এবং রেসপন্স ম্যানিপুলেশন করতে পারে

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২০. কোন টেস্টিং ফ্রেমওয়ার্ক NestJS এর সাথে সেরা কাজ করে?

NestJS **Jest** ব্যবহার করে ডিফল্ট টেস্টিং ফ্রেমওয়ার্ক হিসেবে। অন্যান্য বিকল্প:

-   **Mocha**
-   **Jasmine**
-   **Supertest** (E2E testing)

```typescript
describe("CatsController", () => {
	let controller: CatsController;
	let service: CatsService;

	beforeEach(async () => {
		const module: TestingModule = await Test.createTestingModule({
			controllers: [CatsController],
			providers: [CatsService],
		}).compile();

		controller = module.get<CatsController>(CatsController);
		service = module.get<CatsService>(CatsService);
	});

	it("should be defined", () => {
		expect(controller).toBeDefined();
	});
});
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২১. NestJS এ DTOs (Data Transfer Objects) এর উদ্দেশ্য ব্যাখ্যা করুন

DTOs ডেটা ট্রান্সফারের কাঠামো নির্ধারণ করে। এর প্রধান সুবিধা:

-   **Validation:** ডেটা ভ্যালিডেশন
-   **Documentation:** API ডকুমেন্টেশন
-   **Type Safety:** TypeScript টাইপ সেফটি

```typescript
import { IsString, IsInt, IsEmail, Min, Max } from 'class-validator';

export class CreateUserDto {
  @IsString()
  name: string;

  @IsInt()
  @Min(18)
  @Max(100)
  age: number;

  @IsEmail()
  email: string;
}

// Controller এ ব্যবহার
@Post()
create(@Body() createUserDto: CreateUserDto) {
  return this.usersService.create(createUserDto);
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২২. NestJS এ অ্যাসিঙ্ক্রোনাস অপারেশন এবং Promise এর ভূমিকা

NestJS সম্পূর্ণভাবে async/await সমর্থন করে। Promise ভবিষ্যতের কোনো মান প্রতিনিধিত্ব করে।

```typescript
@Injectable()
export class UsersService {
	async findAll(): Promise<User[]> {
		const users = await this.userRepository.find();
		return users;
	}

	async findOne(id: number): Promise<User> {
		const user = await this.userRepository.findOne({ where: { id } });
		if (!user) {
			throw new NotFoundException(`User #${id} খুঁজে পাওয়া যায়নি`);
		}
		return user;
	}
}
```

**Observable ব্যবহার:**

```typescript
import { Observable } from 'rxjs';

@Get()
findAll(): Observable<User[]> {
  return from(this.usersService.findAll());
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২৩. `@InjectRepository()` ডেকোরেটরের উদ্দেশ্য

TypeORM রিপোজিটরি ইনজেক্ট করার জন্য ব্যবহৃত হয়।

```typescript
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { User } from "./user.entity";

@Injectable()
export class UsersService {
	constructor(
		@InjectRepository(User)
		private usersRepository: Repository<User>,
	) {}

	findAll(): Promise<User[]> {
		return this.usersRepository.find();
	}

	findOne(id: number): Promise<User> {
		return this.usersRepository.findOne({ where: { id } });
	}

	async create(user: User): Promise<User> {
		return this.usersRepository.save(user);
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২৪. `@nestjs/jwt` প্যাকেজের উদ্দেশ্য

JWT (JSON Web Token) জেনারেট এবং ভেরিফাই করার জন্য ব্যবহৃত হয়।

```typescript
import { JwtService } from "@nestjs/jwt";

@Injectable()
export class AuthService {
	constructor(private jwtService: JwtService) {}

	async login(user: User) {
		const payload = { username: user.username, sub: user.id };
		return {
			access_token: this.jwtService.sign(payload),
		};
	}

	async verify(token: string) {
		try {
			const payload = this.jwtService.verify(token);
			return payload;
		} catch (error) {
			throw new UnauthorizedException("Invalid token");
		}
	}
}

// Module সেটআপ
@Module({
	imports: [
		JwtModule.register({
			secret: "secretKey",
			signOptions: { expiresIn: "1h" },
		}),
	],
	providers: [AuthService],
})
export class AuthModule {}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২৫. Authentication এবং Authorization এর পার্থক্য

**Authentication (অথেন্টিকেশন):** ব্যবহারকারী কে তা যাচাই করা

**Authorization (অথরাইজেশন):** ব্যবহারকারী কি করতে পারবে তা নির্ধারণ

```typescript
// Authentication - JWT Strategy
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
	constructor() {
		super({
			jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
			secretOrKey: "secret",
		});
	}

	async validate(payload: any) {
		return { userId: payload.sub, username: payload.username };
	}
}

// Authorization - Roles Guard
@Injectable()
export class RolesGuard implements CanActivate {
	constructor(private reflector: Reflector) {}

	canActivate(context: ExecutionContext): boolean {
		const requiredRoles = this.reflector.get<string[]>("roles", context.getHandler());
		if (!requiredRoles) {
			return true;
		}
		const { user } = context.switchToHttp().getRequest();
		return requiredRoles.some((role) => user.roles?.includes(role));
	}
}

// ব্যবহার
@Controller("admin")
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles("admin")
export class AdminController {
	@Get()
	getData() {
		return "শুধুমাত্র admin দেখতে পারবে";
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২৬. টোকেন এক্সপায়ারেশনের গুরুত্ব এবং Refresh Token

**টোকেন এক্সপায়ারেশন গুরুত্বপূর্ণ কারণ:**

-   নিরাপত্তা বৃদ্ধি
-   চুরি হওয়া টোকেনের ক্ষতি সীমিত করা

```typescript
@Injectable()
export class AuthService {
	constructor(private jwtService: JwtService) {}

	async login(user: User) {
		const payload = { username: user.username, sub: user.id };

		return {
			access_token: this.jwtService.sign(payload, { expiresIn: "15m" }),
			refresh_token: this.jwtService.sign(payload, { expiresIn: "7d" }),
		};
	}

	async refreshToken(refreshToken: string) {
		try {
			const payload = this.jwtService.verify(refreshToken);
			const newPayload = { username: payload.username, sub: payload.sub };

			return {
				access_token: this.jwtService.sign(newPayload, { expiresIn: "15m" }),
			};
		} catch (error) {
			throw new UnauthorizedException("Invalid refresh token");
		}
	}
}

// Controller
@Controller("auth")
export class AuthController {
	constructor(private authService: AuthService) {}

	@Post("refresh")
	async refresh(@Body("refresh_token") refreshToken: string) {
		return this.authService.refreshToken(refreshToken);
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২৭. Token Refresh মেকানিজম

Refresh token ব্যবহারকারীকে পুনরায় লগইন না করে নতুন access token পেতে সাহায্য করে।

**প্রক্রিয়া:**

1. ইউজার লগইন করে access token এবং refresh token পায়
2. Access token expire হলে client refresh token পাঠায়
3. সার্ভার refresh token যাচাই করে নতুন access token দেয়
4. Refresh token ডাটাবেসে সংরক্ষণ করা হয়

```typescript
import { Entity, Column, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class RefreshToken {
	@PrimaryGeneratedColumn()
	id: number;

	@Column()
	token: string;

	@Column()
	userId: number;

	@Column()
	expiresAt: Date;

	@Column({ default: false })
	isRevoked: boolean;
}

@Injectable()
export class AuthService {
	constructor(
		private jwtService: JwtService,
		@InjectRepository(RefreshToken)
		private refreshTokenRepository: Repository<RefreshToken>,
	) {}

	async createRefreshToken(userId: number): Promise<string> {
		const token = this.jwtService.sign({ sub: userId }, { expiresIn: "7d" });

		await this.refreshTokenRepository.save({
			token,
			userId,
			expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
		});

		return token;
	}

	async validateRefreshToken(token: string): Promise<User> {
		const storedToken = await this.refreshTokenRepository.findOne({
			where: { token, isRevoked: false },
		});

		if (!storedToken || storedToken.expiresAt < new Date()) {
			throw new UnauthorizedException("Invalid refresh token");
		}

		const payload = this.jwtService.verify(token);
		return this.usersService.findOne(payload.sub);
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২৮. NestJS এ Authentication এবং Authorization সমর্থন

NestJS Passport.js ইন্টিগ্রেশনের মাধ্যমে বিভিন্ন strategy সমর্থন করে:

```typescript
// JWT Strategy
import { ExtractJwt, Strategy } from "passport-jwt";
import { PassportStrategy } from "@nestjs/passport";
import { Injectable } from "@nestjs/common";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
	constructor() {
		super({
			jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
			ignoreExpiration: false,
			secretOrKey: "yourSecretKey",
		});
	}

	async validate(payload: any) {
		return { userId: payload.sub, username: payload.username };
	}
}

// Local Strategy (Username/Password)
import { Strategy } from "passport-local";
import { PassportStrategy } from "@nestjs/passport";
import { Injectable, UnauthorizedException } from "@nestjs/common";

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
	constructor(private authService: AuthService) {
		super();
	}

	async validate(username: string, password: string): Promise<any> {
		const user = await this.authService.validateUser(username, password);
		if (!user) {
			throw new UnauthorizedException();
		}
		return user;
	}
}

// Guards
@Injectable()
export class JwtAuthGuard extends AuthGuard("jwt") {}

@Injectable()
export class LocalAuthGuard extends AuthGuard("local") {}

// ব্যবহার
@Controller("auth")
export class AuthController {
	@UseGuards(LocalAuthGuard)
	@Post("login")
	async login(@Request() req) {
		return this.authService.login(req.user);
	}

	@UseGuards(JwtAuthGuard)
	@Get("profile")
	getProfile(@Request() req) {
		return req.user;
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ২৯. Provider এবং Services এর পার্থক্য

**Provider:** একটি সাধারণ ধারণা। যেকোনো কিছু যা DI container দ্বারা পরিচালিত হয়।

**Service:** একটি নির্দিষ্ট ধরনের provider যা `@Injectable()` ডেকোরেটর ব্যবহার করে।

```typescript
// Service (যা একটি Provider)
@Injectable()
export class CatsService {
	findAll() {
		return ["cat1", "cat2"];
	}
}

// Custom Provider (Value Provider)
const configProvider = {
	provide: "CONFIG",
	useValue: { apiKey: "123", database: "mongodb://..." },
};

// Custom Provider (Factory Provider)
const databaseProvider = {
	provide: "DATABASE_CONNECTION",
	useFactory: async () => {
		const connection = await createConnection();
		return connection;
	},
};

// Custom Provider (Class Provider)
const loggerProvider = {
	provide: Logger,
	useClass: CustomLogger,
};

// Module এ ব্যবহার
@Module({
	providers: [
		CatsService, // Standard Service
		configProvider, // Value Provider
		databaseProvider, // Factory Provider
		loggerProvider, // Class Provider
	],
})
export class AppModule {}

// Injectable ছাড়া Provider
const connectionProvider = {
	provide: "CONNECTION",
	useValue: "database connection string",
};
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩০. কাস্টম প্রোভাইডার কি এবং স্ট্যান্ডার্ড থেকে পার্থক্য

**Standard Provider:** `@Injectable()` ডেকোরেটর সহ ক্লাস

**Custom Provider:** useValue, useClass, useFactory, useExisting ব্যবহার করে তৈরি

### Custom Provider এর প্রকার:

**১. Value Provider:**

```typescript
const configProvider = {
	provide: "CONFIG_OPTIONS",
	useValue: {
		apiKey: "my-api-key",
		timeout: 5000,
	},
};
```

**২. Class Provider:**

```typescript
const loggerProvider = {
	provide: Logger,
	useClass: process.env.NODE_ENV === "development" ? DevLogger : ProdLogger,
};
```

**৩. Factory Provider:**

```typescript
const databaseProvider = {
	provide: "DATABASE",
	useFactory: (config: ConfigService) => {
		return createDatabaseConnection(config.get("DB_URL"));
	},
	inject: [ConfigService],
};
```

**৪. Existing Provider (Alias):**

```typescript
const aliasProvider = {
	provide: "AliasedLogger",
	useExisting: Logger,
};
```

**সম্পূর্ণ উদাহরণ:**

```typescript
@Module({
	providers: [
		// Standard Provider
		AppService,

		// Custom Providers
		{
			provide: "API_KEY",
			useValue: "my-secret-key",
		},
		{
			provide: "ASYNC_CONNECTION",
			useFactory: async () => {
				const connection = await createConnection();
				return connection;
			},
		},
		{
			provide: Logger,
			useClass: CustomLogger,
		},
	],
})
export class AppModule {}

// ব্যবহার
@Injectable()
export class AppService {
	constructor(
		@Inject("API_KEY") private apiKey: string,
		@Inject("ASYNC_CONNECTION") private connection: Connection,
		private logger: Logger,
	) {}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩১. Swagger ব্যবহার করে API ডকুমেন্টেশন কিভাবে জেনারেট করবেন?

Swagger হল API ডকুমেন্টেশনের জন্য একটি শক্তিশালী টুল। NestJS এ `@nestjs/swagger` প্যাকেজ ব্যবহার করা হয়।

### ইনস্টলেশন:

```bash
npm install --save @nestjs/swagger
```

### সেটআপ (main.ts):

```typescript
import { NestFactory } from "@nestjs/core";
import { SwaggerModule, DocumentBuilder } from "@nestjs/swagger";
import { AppModule } from "./app.module";

async function bootstrap() {
	const app = await NestFactory.create(AppModule);

	const config = new DocumentBuilder()
		.setTitle("NestJS API")
		.setDescription("API ডকুমেন্টেশন")
		.setVersion("1.0")
		.addTag("users")
		.addBearerAuth()
		.build();

	const document = SwaggerModule.createDocument(app, config);
	SwaggerModule.setup("api-docs", app, document);

	await app.listen(3000);
}
bootstrap();
```

### DTO তে Swagger ডেকোরেটর:

```typescript
import { ApiProperty } from "@nestjs/swagger";
import { IsString, IsInt, IsEmail } from "class-validator";

export class CreateUserDto {
	@ApiProperty({ description: "ব্যবহারকারীর নাম", example: "জন ডো" })
	@IsString()
	name: string;

	@ApiProperty({ description: "ব্যবহারকারীর বয়স", minimum: 18, maximum: 100, example: 25 })
	@IsInt()
	age: number;

	@ApiProperty({ description: "ই-মেইল ঠিকানা", example: "john@example.com" })
	@IsEmail()
	email: string;
}
```

### Controller এ Swagger ডেকোরেটর:

```typescript
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from "@nestjs/swagger";

@ApiTags("users")
@Controller("users")
export class UsersController {
	@Post()
	@ApiOperation({ summary: "নতুন ইউজার তৈরি" })
	@ApiResponse({ status: 201, description: "ইউজার সফলভাবে তৈরি হয়েছে" })
	@ApiResponse({ status: 400, description: "Bad Request" })
	create(@Body() createUserDto: CreateUserDto) {
		return this.usersService.create(createUserDto);
	}

	@Get()
	@ApiBearerAuth()
	@ApiOperation({ summary: "সব ইউজার দেখুন" })
	@ApiResponse({ status: 200, description: "সফল", type: [User] })
	findAll() {
		return this.usersService.findAll();
	}
}
```

**সুবিধা:**
- স্বয়ংক্রিয় API ডকুমেন্টেশন
- Interactive API testing UI
- API স্পেসিফিকেশন এক্সপোর্ট
- ডেভেলপার collaboration সহজ

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩২. ApiProperty() এবং ApiOperation() ডেকোরেটরের উদ্দেশ্য

### ApiProperty()
DTO ক্লাসের প্রপার্টির জন্য মেটাডেটা প্রদান করে।

```typescript
export class CreateProductDto {
	@ApiProperty({
		description: "পণ্যের নাম",
		example: "ল্যাপটপ",
		required: true,
	})
	name: string;

	@ApiProperty({
		description: "পণ্যের মূল্য",
		example: 50000,
		minimum: 0,
		type: Number,
	})
	price: number;

	@ApiProperty({
		description: "পণ্যের বিবরণ",
		example: "একটি উচ্চ মানের ল্যাপটপ",
		required: false,
	})
	description?: string;

	@ApiProperty({
		description: "পণ্যের ক্যাটাগরি",
		enum: ["electronics", "clothing", "food"],
		example: "electronics",
	})
	category: string;
}
```

### ApiOperation()
API endpoint এর বিবরণ প্রদান করে।

```typescript
@Controller("products")
export class ProductsController {
	@Post()
	@ApiOperation({
		summary: "নতুন পণ্য যোগ করুন",
		description: "এই endpoint নতুন পণ্য ডাটাবেসে যোগ করে",
	})
	@ApiResponse({ status: 201, description: "পণ্য তৈরি হয়েছে" })
	create(@Body() dto: CreateProductDto) {
		return this.productsService.create(dto);
	}

	@Get(":id")
	@ApiOperation({ summary: "ID দিয়ে পণ্য খুঁজুন" })
	@ApiParam({ name: "id", description: "পণ্যের ID" })
	findOne(@Param("id") id: string) {
		return this.productsService.findOne(+id);
	}
}
```

### অন্যান্য Swagger ডেকোরেটর:

```typescript
@ApiTags("products") // গ্রুপিং
@ApiBearerAuth() // Authentication
@ApiHeader() // Custom headers
@ApiQuery() // Query parameters
@ApiParam() // Route parameters
@ApiBody() // Request body
@ApiResponse() // Response specification
@ApiExcludeEndpoint() // Hide from docs
@ApiExtraModels() // Extra models
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩৩. Dockerfile এর উদ্দেশ্য এবং কন্টেইনারাইজেশন

Dockerfile হল একটি টেক্সট ফাইল যা Docker image তৈরির নির্দেশনা ধারণ করে।

### NestJS এর জন্য Dockerfile:

```dockerfile
# Base image
FROM node:18-alpine AS development

# Working directory
WORKDIR /usr/src/app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Production stage
FROM node:18-alpine AS production

WORKDIR /usr/src/app

COPY package*.json ./

# Install only production dependencies
RUN npm ci --only=production

# Copy built files from development stage
COPY --from=development /usr/src/app/dist ./dist

# Expose port
EXPOSE 3000

# Start command
CMD ["node", "dist/main"]
```

### Multi-stage Build এর সুবিধা:

```dockerfile
# Stage 1: Build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
EXPOSE 3000
CMD ["node", "dist/main.js"]
```

### .dockerignore ফাইল:

```
node_modules
npm-debug.log
dist
.env
.git
.gitignore
README.md
.vscode
coverage
.jest
```

### Docker commands:

```bash
# Image তৈরি
docker build -t nestjs-app .

# Container চালানো
docker run -p 3000:3000 nestjs-app

# Environment variables সহ
docker run -p 3000:3000 -e DATABASE_URL=mongodb://localhost:27017 nestjs-app
```

**কন্টেইনারাইজেশনের সুবিধা:**
- Consistency across environments
- Easy deployment
- Scalability
- Isolation
- Resource efficiency

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩৪. Docker Compose এর ভূমিকা এবং মাল্টি-কন্টেইনার সেটআপ

Docker Compose একাধিক container পরিচালনা করতে ব্যবহৃত হয়।

### docker-compose.yml:

```yaml
version: "3.8"

services:
    app:
        build:
            context: .
            dockerfile: Dockerfile
        ports:
            - "3000:3000"
        environment:
            - DATABASE_URL=mongodb://mongo:27017/nestjs
            - REDIS_URL=redis://redis:6379
        depends_on:
            - mongo
            - redis
        volumes:
            - ./src:/usr/src/app/src
        networks:
            - app-network

    mongo:
        image: mongo:latest
        ports:
            - "27017:27017"
        volumes:
            - mongo-data:/data/db
        environment:
            - MONGO_INITDB_ROOT_USERNAME=admin
            - MONGO_INITDB_ROOT_PASSWORD=password
        networks:
            - app-network

    redis:
        image: redis:alpine
        ports:
            - "6379:6379"
        volumes:
            - redis-data:/data
        networks:
            - app-network

    postgres:
        image: postgres:14-alpine
        ports:
            - "5432:5432"
        environment:
            - POSTGRES_USER=user
            - POSTGRES_PASSWORD=password
            - POSTGRES_DB=nestjs_db
        volumes:
            - postgres-data:/var/lib/postgresql/data
        networks:
            - app-network

volumes:
    mongo-data:
    redis-data:
    postgres-data:

networks:
    app-network:
        driver: bridge
```

### Production docker-compose:

```yaml
version: "3.8"

services:
    nginx:
        image: nginx:alpine
        ports:
            - "80:80"
            - "443:443"
        volumes:
            - ./nginx.conf:/etc/nginx/nginx.conf
        depends_on:
            - app
        networks:
            - app-network

    app:
        build:
            context: .
            dockerfile: Dockerfile.prod
        environment:
            - NODE_ENV=production
        deploy:
            replicas: 3
            restart_policy:
                condition: on-failure
        networks:
            - app-network

    db:
        image: postgres:14-alpine
        environment:
            - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
        secrets:
            - db_password
        volumes:
            - db-data:/var/lib/postgresql/data
        networks:
            - app-network

secrets:
    db_password:
        file: ./secrets/db_password.txt

volumes:
    db-data:

networks:
    app-network:
```

### Docker Compose কমান্ড:

```bash
# সব services শুরু করুন
docker-compose up

# Background এ চালান
docker-compose up -d

# Rebuild করে শুরু করুন
docker-compose up --build

# বন্ধ করুন
docker-compose down

# Volumes সহ বন্ধ
docker-compose down -v

# Logs দেখুন
docker-compose logs -f app

# Specific service চালান
docker-compose up app
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩৫. @nestjs/passport এর উদ্দেশ্য এবং Authentication

`@nestjs/passport` হল Passport.js এর NestJS wrapper যা authentication সহজ করে।

### ইনস্টলেশন:

```bash
npm install @nestjs/passport passport
npm install passport-local passport-jwt
npm install @types/passport-local @types/passport-jwt
```

### Local Strategy (Username/Password):

```typescript
import { Strategy } from "passport-local";
import { PassportStrategy } from "@nestjs/passport";
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { AuthService } from "./auth.service";

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
	constructor(private authService: AuthService) {
		super({
			usernameField: "email", // ডিফল্ট 'username'
			passwordField: "password",
		});
	}

	async validate(email: string, password: string): Promise<any> {
		const user = await this.authService.validateUser(email, password);
		if (!user) {
			throw new UnauthorizedException("Invalid credentials");
		}
		return user;
	}
}
```

### JWT Strategy:

```typescript
import { ExtractJwt, Strategy } from "passport-jwt";
import { PassportStrategy } from "@nestjs/passport";
import { Injectable } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
	constructor(private configService: ConfigService) {
		super({
			jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
			ignoreExpiration: false,
			secretOrKey: configService.get("JWT_SECRET"),
		});
	}

	async validate(payload: any) {
		return {
			userId: payload.sub,
			username: payload.username,
			roles: payload.roles,
		};
	}
}
```

### OAuth Strategy (Google):

```typescript
import { Strategy, VerifyCallback } from "passport-google-oauth20";
import { PassportStrategy } from "@nestjs/passport";
import { Injectable } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, "google") {
	constructor(private configService: ConfigService) {
		super({
			clientID: configService.get("GOOGLE_CLIENT_ID"),
			clientSecret: configService.get("GOOGLE_CLIENT_SECRET"),
			callbackURL: "http://localhost:3000/auth/google/callback",
			scope: ["email", "profile"],
		});
	}

	async validate(accessToken: string, refreshToken: string, profile: any, done: VerifyCallback): Promise<any> {
		const { name, emails, photos } = profile;
		const user = {
			email: emails[0].value,
			firstName: name.givenName,
			lastName: name.familyName,
			picture: photos[0].value,
			accessToken,
		};
		done(null, user);
	}
}
```

### Auth Module সেটআপ:

```typescript
import { Module } from "@nestjs/common";
import { PassportModule } from "@nestjs/passport";
import { JwtModule } from "@nestjs/jwt";
import { AuthService } from "./auth.service";
import { AuthController } from "./auth.controller";
import { LocalStrategy } from "./strategies/local.strategy";
import { JwtStrategy } from "./strategies/jwt.strategy";
import { GoogleStrategy } from "./strategies/google.strategy";

@Module({
	imports: [
		PassportModule,
		JwtModule.register({
			secret: process.env.JWT_SECRET,
			signOptions: { expiresIn: "1h" },
		}),
	],
	providers: [AuthService, LocalStrategy, JwtStrategy, GoogleStrategy],
	controllers: [AuthController],
})
export class AuthModule {}
```

### Guards ব্যবহার:

```typescript
@Controller("auth")
export class AuthController {
	@UseGuards(LocalAuthGuard)
	@Post("login")
	async login(@Request() req) {
		return this.authService.login(req.user);
	}

	@UseGuards(JwtAuthGuard)
	@Get("profile")
	getProfile(@Request() req) {
		return req.user;
	}

	@Get("google")
	@UseGuards(GoogleAuthGuard)
	async googleAuth() {}

	@Get("google/callback")
	@UseGuards(GoogleAuthGuard)
	googleAuthRedirect(@Request() req) {
		return this.authService.googleLogin(req.user);
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩৬. ফাইল আপলোড হ্যান্ডলিং এবং Multer লাইব্রেরি

NestJS ফাইল আপলোডের জন্য Multer ব্যবহার করে।

### ইনস্টলেশন:

```bash
npm install @nestjs/platform-express @types/multer
```

### একক ফাইল আপলোড:

```typescript
import { Controller, Post, UseInterceptors, UploadedFile } from "@nestjs/common";
import { FileInterceptor } from "@nestjs/platform-express";
import { diskStorage } from "multer";
import { extname } from "path";

@Controller("upload")
export class UploadController {
	@Post("single")
	@UseInterceptors(FileInterceptor("file"))
	uploadFile(@UploadedFile() file: Express.Multer.File) {
		console.log(file);
		return {
			filename: file.filename,
			originalname: file.originalname,
			size: file.size,
			path: file.path,
		};
	}
}
```

### একাধিক ফাইল আপলোড:

```typescript
import { FilesInterceptor } from "@nestjs/platform-express";

@Controller("upload")
export class UploadController {
	@Post("multiple")
	@UseInterceptors(FilesInterceptor("files", 10)) // সর্বোচ্চ 10টি ফাইল
	uploadMultipleFiles(@UploadedFiles() files: Array<Express.Multer.File>) {
		return files.map((file) => ({
			filename: file.filename,
			size: file.size,
		}));
	}
}
```

### কাস্টম Multer কনফিগারেশন:

```typescript
import { Module } from "@nestjs/common";
import { MulterModule } from "@nestjs/platform-express";
import { diskStorage } from "multer";
import { v4 as uuidv4 } from "uuid";
import { extname } from "path";

@Module({
	imports: [
		MulterModule.register({
			storage: diskStorage({
				destination: "./uploads",
				filename: (req, file, callback) => {
					const uniqueName = `${uuidv4()}${extname(file.originalname)}`;
					callback(null, uniqueName);
				},
			}),
			fileFilter: (req, file, callback) => {
				if (!file.originalname.match(/\.(jpg|jpeg|png|gif)$/)) {
					return callback(new Error("শুধুমাত্র ছবি ফাইল অনুমোদিত!"), false);
				}
				callback(null, true);
			},
			limits: {
				fileSize: 5 * 1024 * 1024, // 5MB
			},
		}),
	],
})
export class UploadModule {}
```

### ফাইল ভ্যালিডেশন পাইপ:

```typescript
import { ParseFilePipe, MaxFileSizeValidator, FileTypeValidator } from "@nestjs/common";

@Post("validated")
@UseInterceptors(FileInterceptor("file"))
uploadValidatedFile(
	@UploadedFile(
		new ParseFilePipe({
			validators: [
				new MaxFileSizeValidator({ maxSize: 5000000 }), // 5MB
				new FileTypeValidator({ fileType: "image/jpeg" }),
			],
		}),
	)
	file: Express.Multer.File,
) {
	return { message: "ফাইল সফলভাবে আপলোড হয়েছে", file };
}
```

### AWS S3 এ আপলোড:

```typescript
import { S3 } from "aws-sdk";
import { Injectable } from "@nestjs/common";

@Injectable()
export class S3Service {
	private s3: S3;

	constructor() {
		this.s3 = new S3({
			accessKeyId: process.env.AWS_ACCESS_KEY,
			secretAccessKey: process.env.AWS_SECRET_KEY,
			region: process.env.AWS_REGION,
		});
	}

	async uploadFile(file: Express.Multer.File) {
		const params = {
			Bucket: process.env.AWS_BUCKET_NAME,
			Key: `${Date.now()}-${file.originalname}`,
			Body: file.buffer,
			ACL: "public-read",
			ContentType: file.mimetype,
		};

		return await this.s3.upload(params).promise();
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩৭. ডেটাবেস ইন্টারঅ্যাকশন এবং সমর্থিত ডেটাবেস

NestJS বিভিন্ন ডেটাবেসের সাথে কাজ করার জন্য ORM সমর্থন করে।

### সমর্থিত ডেটাবেস:
- PostgreSQL
- MySQL / MariaDB
- MongoDB
- SQLite
- Microsoft SQL Server
- Oracle
- CockroachDB

### TypeORM সেটআপ (PostgreSQL):

```bash
npm install @nestjs/typeorm typeorm pg
```

```typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";

@Module({
	imports: [
		TypeOrmModule.forRoot({
			type: "postgres",
			host: "localhost",
			port: 5432,
			username: "postgres",
			password: "password",
			database: "nestjs_db",
			entities: [__dirname + "/**/*.entity{.ts,.js}"],
			synchronize: true, // প্রোডাকশনে false করুন
			logging: true,
		}),
	],
})
export class AppModule {}
```

### Entity তৈরি:

```typescript
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from "typeorm";

@Entity("users")
export class User {
	@PrimaryGeneratedColumn()
	id: number;

	@Column({ unique: true })
	email: string;

	@Column()
	password: string;

	@Column()
	firstName: string;

	@Column()
	lastName: string;

	@Column({ default: true })
	isActive: boolean;

	@CreateDateColumn()
	createdAt: Date;

	@UpdateDateColumn()
	updatedAt: Date;
}
```

### Repository ব্যবহার:

```typescript
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { User } from "./user.entity";

@Injectable()
export class UsersService {
	constructor(
		@InjectRepository(User)
		private usersRepository: Repository<User>,
	) {}

	async findAll(): Promise<User[]> {
		return await this.usersRepository.find();
	}

	async findOne(id: number): Promise<User> {
		return await this.usersRepository.findOne({ where: { id } });
	}

	async create(userData: Partial<User>): Promise<User> {
		const user = this.usersRepository.create(userData);
		return await this.usersRepository.save(user);
	}

	async update(id: number, userData: Partial<User>): Promise<User> {
		await this.usersRepository.update(id, userData);
		return this.findOne(id);
	}

	async remove(id: number): Promise<void> {
		await this.usersRepository.delete(id);
	}
}
```

### Mongoose সেটআপ (MongoDB):

```bash
npm install @nestjs/mongoose mongoose
```

```typescript
import { Module } from "@nestjs/common";
import { MongooseModule } from "@nestjs/mongoose";

@Module({
	imports: [MongooseModule.forRoot("mongodb://localhost:27017/nestjs")],
})
export class AppModule {}
```

### Schema তৈরি:

```typescript
import { Prop, Schema, SchemaFactory } from "@nestjs/mongoose";
import { Document } from "mongoose";

@Schema()
export class User extends Document {
	@Prop({ required: true })
	name: string;

	@Prop({ required: true, unique: true })
	email: string;

	@Prop()
	age: number;

	@Prop({ default: Date.now })
	createdAt: Date;
}

export const UserSchema = SchemaFactory.createForClass(User);
```

### Prisma সেটআপ:

```bash
npm install @prisma/client
npm install -D prisma
npx prisma init
```

```prisma
// schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৩৮. Circular Dependency এবং সমাধান

Circular dependency ঘটে যখন দুই বা ততোধিক ক্লাস একে অপরের উপর নির্ভর করে।

### সমস্যা উদাহরণ:

```typescript
// cats.service.ts
@Injectable()
export class CatsService {
	constructor(private dogsService: DogsService) {}
}

// dogs.service.ts
@Injectable()
export class DogsService {
	constructor(private catsService: CatsService) {}
}
// এটি circular dependency error দেবে!
```

### সমাধান ১: forwardRef() ব্যবহার

```typescript
// cats.service.ts
import { Injectable, forwardRef, Inject } from "@nestjs/common";

@Injectable()
export class CatsService {
	constructor(
		@Inject(forwardRef(() => DogsService))
		private dogsService: DogsService,
	) {}

	getCatInfo() {
		return this.dogsService.getDogInfo();
	}
}

// dogs.service.ts
@Injectable()
export class DogsService {
	constructor(
		@Inject(forwardRef(() => CatsService))
		private catsService: CatsService,
	) {}

	getDogInfo() {
		return "Dog info";
	}
}
```

### সমাধান ২: ModuleRef ব্যবহার

```typescript
import { Injectable } from "@nestjs/common";
import { ModuleRef } from "@nestjs/core";

@Injectable()
export class CatsService {
	private dogsService: DogsService;

	constructor(private moduleRef: ModuleRef) {}

	onModuleInit() {
		this.dogsService = this.moduleRef.get(DogsService, { strict: false });
	}

	getCatInfo() {
		return this.dogsService.getDogInfo();
	}
}
```

### সমাধান ৩: আর্কিটেকচার পুনর্গঠন (সেরা পদ্ধতি)

```typescript
// একটি shared service তৈরি করুন
@Injectable()
export class AnimalsService {
	getCatInfo() {
		return "Cat info";
	}

	getDogInfo() {
		return "Dog info";
	}
}

// cats.service.ts
@Injectable()
export class CatsService {
	constructor(private animalsService: AnimalsService) {}

	getCatInfo() {
		return this.animalsService.getCatInfo();
	}
}

// dogs.service.ts
@Injectable()
export class DogsService {
	constructor(private animalsService: AnimalsService) {}

	getDogInfo() {
		return this.animalsService.getDogInfo();
	}
}
```

### Module লেভেলে Circular Dependency:

```typescript
// users.module.ts
import { Module, forwardRef } from "@nestjs/common";
import { PostsModule } from "../posts/posts.module";

@Module({
	imports: [forwardRef(() => PostsModule)],
	providers: [UsersService],
	exports: [UsersService],
})
export class UsersModule {}

// posts.module.ts
@Module({
	imports: [forwardRef(() => UsersModule)],
	providers: [PostsService],
	exports: [PostsService],
})
export class PostsModule {}
```

**সেরা অনুশীলন:**
- Circular dependency এড়ানোর চেষ্টা করুন
- আর্কিটেকচার ডিজাইনে সতর্ক থাকুন
- Shared services ব্যবহার করুন
- Event-driven আর্কিটেকচার বিবেচনা করুন

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**


## ৩৯. এরর হ্যান্ডলিং

NestJS এ এরর হ্যান্ডলিং Exception filters ব্যবহার করে করা হয়।

### বিল্ট-ইন HTTP Exceptions:

```typescript
import {
	BadRequestException,
	UnauthorizedException,
	NotFoundException,
	ForbiddenException,
	NotAcceptableException,
	RequestTimeoutException,
	ConflictException,
	GoneException,
	PayloadTooLargeException,
	UnsupportedMediaTypeException,
	UnprocessableEntityException,
	InternalServerErrorException,
	NotImplementedException,
	BadGatewayException,
	ServiceUnavailableException,
	GatewayTimeoutException,
} from "@nestjs/common";

@Get(":id")
async findOne(@Param("id") id: string) {
  const user = await this.usersService.findOne(id);
  if (!user) {
    throw new NotFoundException(`User #${id} খুঁজে পাওয়া যায়নি`);
  }
  return user;
}
```

### কাস্টম Exception:

```typescript
export class UserNotFoundException extends NotFoundException {
	constructor(userId: string) {
		super(`ইউজার #${userId} খুঁজে পাওয়া যায়নি`);
	}
}

// ব্যবহার
throw new UserNotFoundException("123");
```

### Exception Filter:

```typescript
import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from "@nestjs/common";
import { Request, Response } from "express";

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
	catch(exception: HttpException, host: ArgumentsHost) {
		const ctx = host.switchToHttp();
		const response = ctx.getResponse<Response>();
		const request = ctx.getRequest<Request>();
		const status = exception.getStatus();
		const exceptionResponse = exception.getResponse();

		response.status(status).json({
			statusCode: status,
			timestamp: new Date().toISOString(),
			path: request.url,
			message: typeof exceptionResponse === "object" ? exceptionResponse["message"] : exceptionResponse,
		});
	}
}
```

### Global Exception Filter:

```typescript
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
	catch(exception: unknown, host: ArgumentsHost) {
		const ctx = host.switchToHttp();
		const response = ctx.getResponse();
		const request = ctx.getRequest();

		const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR;

		const message =
			exception instanceof HttpException
				? exception.getResponse()
				: {
						statusCode: status,
						message: "Internal server error",
				  };

		response.status(status).json({
			...message,
			timestamp: new Date().toISOString(),
			path: request.url,
		});
	}
}

// main.ts এ
app.useGlobalFilters(new AllExceptionsFilter());
```

### Business Logic Exception:

```typescript
export class InsufficientBalanceException extends HttpException {
	constructor(currentBalance: number, requiredAmount: number) {
		super(
			{
				statusCode: HttpStatus.BAD_REQUEST,
				message: "অপর্যাপ্ত ব্যালেন্স",
				error: "INSUFFICIENT_BALANCE",
				details: {
					currentBalance,
					requiredAmount,
					shortfall: requiredAmount - currentBalance,
				},
			},
			HttpStatus.BAD_REQUEST,
		);
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪০. CORS (Cross-Origin Resource Sharing) হ্যান্ডলিং

CORS হল একটি নিরাপত্তা ফিচার যা cross-origin requests নিয়ন্ত্রণ করে।

### সিম্পল CORS সক্রিয়করণ:

```typescript
// main.ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
	const app = await NestFactory.create(AppModule);
	app.enableCors(); // সব origin অনুমোদন
	await app.listen(3000);
}
bootstrap();
```

### কনফিগার করা CORS:

```typescript
app.enableCors({
	origin: "http://localhost:4200", // নির্দিষ্ট origin
	methods: "GET,HEAD,PUT,PATCH,POST,DELETE", // অনুমোদিত methods
	allowedHeaders: "Content-Type, Authorization", // অনুমোদিত headers
	credentials: true, // cookies পাঠানোর অনুমতি
	preflightContinue: false,
	optionsSuccessStatus: 204,
});
```

### একাধিক Origins:

```typescript
app.enableCors({
	origin: ["http://localhost:3000", "http://localhost:4200", "https://example.com"],
	credentials: true,
});
```

### Dynamic Origin:

```typescript
app.enableCors({
	origin: (origin, callback) => {
		const whitelist = ["http://localhost:3000", "http://localhost:4200"];

		if (!origin || whitelist.indexOf(origin) !== -1) {
			callback(null, true);
		} else {
			callback(new Error("Not allowed by CORS"));
		}
	},
	credentials: true,
});
```

### Environment-based CORS:

```typescript
const corsOptions = {
	origin:
		process.env.NODE_ENV === "production"
			? ["https://yourdomain.com", "https://www.yourdomain.com"]
			: ["http://localhost:3000", "http://localhost:4200"],
	credentials: true,
};

app.enableCors(corsOptions);
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪১. ExecutionContext এর উদ্দেশ্য

ExecutionContext বর্তমান request এর context তথ্য প্রদান করে।

### ExecutionContext ব্যবহার:

```typescript
import { Injectable, CanActivate, ExecutionContext } from "@nestjs/common";

@Injectable()
export class AuthGuard implements CanActivate {
	canActivate(context: ExecutionContext): boolean {
		// HTTP context পেতে
		const request = context.switchToHttp().getRequest();
		const response = context.switchToHttp().getResponse();

		// RPC context
		const rpcContext = context.switchToRpc();

		// WebSocket context
		const wsContext = context.switchToWs();

		// Handler এবং Class তথ্য
		const handler = context.getHandler();
		const controllerClass = context.getClass();

		return true;
	}
}
```

### Reflector দিয়ে Metadata অ্যাক্সেস:

```typescript
import { Injectable, ExecutionContext } from "@nestjs/common";
import { Reflector } from "@nestjs/core";

@Injectable()
export class RolesGuard implements CanActivate {
	constructor(private reflector: Reflector) {}

	canActivate(context: ExecutionContext): boolean {
		// Method এবং Class থেকে metadata
		const roles = this.reflector.getAllAndOverride<string[]>("roles", [
			context.getHandler(),
			context.getClass(),
		]);

		if (!roles) {
			return true;
		}

		const request = context.switchToHttp().getRequest();
		const user = request.user;

		return this.matchRoles(roles, user.roles);
	}

	private matchRoles(requiredRoles: string[], userRoles: string[]): boolean {
		return requiredRoles.some((role) => userRoles.includes(role));
	}
}
```

### Custom Decorator দিয়ে:

```typescript
import { SetMetadata } from "@nestjs/common";

export const Roles = (...roles: string[]) => SetMetadata("roles", roles);

// Controller এ ব্যবহার
@Get()
@Roles("admin", "moderator")
findAll() {
  return [];
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪২. TypeORM এ Soft Delete

Soft delete ডেটা permanently মুছে না দিয়ে deleted হিসেবে চিহ্নিত করে।

### Soft Delete সক্রিয়করণ:

```typescript
import { Entity, Column, PrimaryGeneratedColumn, DeleteDateColumn } from "typeorm";

@Entity()
export class User {
	@PrimaryGeneratedColumn()
	id: number;

	@Column()
	name: string;

	@Column()
	email: string;

	@DeleteDateColumn()
	deletedAt?: Date; // এই column soft delete ট্র্যাক করে
}
```

### Service এ Soft Delete:

```typescript
@Injectable()
export class UsersService {
	constructor(
		@InjectRepository(User)
		private usersRepository: Repository<User>,
	) {}

	// Soft delete
	async softDelete(id: number): Promise<void> {
		await this.usersRepository.softDelete(id);
	}

	// Soft deleted items সহ query
	async findAllWithDeleted(): Promise<User[]> {
		return await this.usersRepository.find({ withDeleted: true });
	}

	// শুধু deleted items
	async findDeleted(): Promise<User[]> {
		return await this.usersRepository
			.createQueryBuilder("user")
			.where("user.deletedAt IS NOT NULL")
			.withDeleted()
			.getMany();
	}

	// Restore soft deleted
	async restore(id: number): Promise<void> {
		await this.usersRepository.restore(id);
	}

	// Hard delete (permanently remove)
	async hardDelete(id: number): Promise<void> {
		await this.usersRepository.delete(id);
	}
}
```

### Multiple IDs Soft Delete:

```typescript
async softDeleteMultiple(ids: number[]): Promise<void> {
  await this.usersRepository.softDelete(ids);
}
```

**সুবিধা:**
- ডেটা recovery সম্ভব
- Audit trail রক্ষা
- Relationship integrity
- অসাবধানে মুছে যাওয়া থেকে সুরক্ষা

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪৩. Environment Variables এবং Configuration Management

Environment variables অ্যাপ্লিকেশন কনফিগারেশন পরিচালনা করে।

### @nestjs/config ব্যবহার:

```bash
npm install @nestjs/config
```

### .env ফাইল:

```env
DATABASE_URL=postgresql://user:password@localhost:5432/mydb
JWT_SECRET=your-secret-key
JWT_EXPIRES_IN=1h
PORT=3000
NODE_ENV=development
REDIS_HOST=localhost
REDIS_PORT=6379
```

### ConfigModule সেটআপ:

```typescript
import { Module } from "@nestjs/common";
import { ConfigModule } from "@nestjs/config";

@Module({
	imports: [
		ConfigModule.forRoot({
			isGlobal: true, // সব মডিউলে accessible
			envFilePath: [".env.local", ".env"], // একাধিক .env files
			ignoreEnvFile: process.env.NODE_ENV === "production",
			cache: true, // performance এর জন্য cache
		}),
	],
})
export class AppModule {}
```

### ConfigService ব্যবহার:

```typescript
import { Injectable } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";

@Injectable()
export class AppService {
	constructor(private configService: ConfigService) {}

	getDatabaseUrl(): string {
		return this.configService.get<string>("DATABASE_URL");
	}

	getPort(): number {
		return this.configService.get<number>("PORT", 3000); // default value
	}

	isProduction(): boolean {
		return this.configService.get("NODE_ENV") === "production";
	}
}
```

### কাস্টম Configuration:

```typescript
// config/database.config.ts
export default () => ({
	database: {
		host: process.env.DATABASE_HOST || "localhost",
		port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
		username: process.env.DATABASE_USER,
		password: process.env.DATABASE_PASSWORD,
		name: process.env.DATABASE_NAME,
	},
});

// app.module.ts
import databaseConfig from "./config/database.config";

@Module({
	imports: [
		ConfigModule.forRoot({
			load: [databaseConfig],
		}),
	],
})
export class AppModule {}

// ব্যবহার
const dbHost = this.configService.get<string>("database.host");
```

### Validation Schema:

```typescript
import * as Joi from "joi";

ConfigModule.forRoot({
	validationSchema: Joi.object({
		NODE_ENV: Joi.string().valid("development", "production", "test").default("development"),
		PORT: Joi.number().default(3000),
		DATABASE_URL: Joi.string().required(),
		JWT_SECRET: Joi.string().required(),
	}),
});
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪৪. TypeORM Migrations

Migrations ডেটাবেস schema changes ভার্সন কন্ট্রোল করে।

### ormconfig.json:

```json
{
	"type": "postgres",
	"host": "localhost",
	"port": 5432,
	"username": "postgres",
	"password": "password",
	"database": "nestjs_db",
	"entities": ["dist/**/*.entity{.ts,.js}"],
	"migrations": ["dist/migrations/*{.ts,.js}"],
	"cli": {
		"migrationsDir": "src/migrations"
	},
	"synchronize": false
}
```

### Migration তৈরি:

```bash
npm run typeorm migration:generate -- -n CreateUsersTable
```

### Migration ফাইল:

```typescript
import { MigrationInterface, QueryRunner, Table } from "typeorm";

export class CreateUsersTable1234567890123 implements MigrationInterface {
	public async up(queryRunner: QueryRunner): Promise<void> {
		await queryRunner.createTable(
			new Table({
				name: "users",
				columns: [
					{
						name: "id",
						type: "int",
						isPrimary: true,
						isGenerated: true,
						generationStrategy: "increment",
					},
					{
						name: "email",
						type: "varchar",
						isUnique: true,
					},
					{
						name: "password",
						type: "varchar",
					},
					{
						name: "firstName",
						type: "varchar",
					},
					{
						name: "lastName",
						type: "varchar",
					},
					{
						name: "createdAt",
						type: "timestamp",
						default: "now()",
					},
				],
			}),
			true,
		);
	}

	public async down(queryRunner: QueryRunner): Promise<void> {
		await queryRunner.dropTable("users");
	}
}
```

### Column যোগ করা:

```typescript
export class AddAgeToUsers1234567890124 implements MigrationInterface {
	public async up(queryRunner: QueryRunner): Promise<void> {
		await queryRunner.addColumn(
			"users",
			new TableColumn({
				name: "age",
				type: "int",
				isNullable: true,
			}),
		);
	}

	public async down(queryRunner: QueryRunner): Promise<void> {
		await queryRunner.dropColumn("users", "age");
	}
}
```

### Migration কমান্ড:

```bash
# Migration run করুন
npm run typeorm migration:run

# Migration revert করুন
npm run typeorm migration:revert

# নতুন migration তৈরি
npm run typeorm migration:create -- -n MigrationName

# Migration status দেখুন
npm run typeorm migration:show
```

### package.json scripts:

```json
{
	"scripts": {
		"typeorm": "ts-node -r tsconfig-paths/register ./node_modules/typeorm/cli.js",
		"migration:generate": "npm run typeorm -- migration:generate -n",
		"migration:create": "npm run typeorm -- migration:create -n",
		"migration:run": "npm run typeorm -- migration:run",
		"migration:revert": "npm run typeorm -- migration:revert"
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪৫. ExecutionContext এর বিস্তারিত ব্যবহার

ExecutionContext request lifecycle এর বিভিন্ন পর্যায়ে context তথ্য প্রদান করে।

### ExecutionContext Methods:

```typescript
import { ExecutionContext } from "@nestjs/common";

class MyGuard {
	canActivate(context: ExecutionContext): boolean {
		// Type পেতে
		const type = context.getType(); // 'http' | 'rpc' | 'ws'

		// Handler function reference
		const handler = context.getHandler();

		// Controller class reference
		const controllerClass = context.getClass();

		// Arguments array
		const args = context.getArgs();

		// Specific argument by index
		const firstArg = context.getArgByIndex(0);

		return true;
	}
}
```

### HTTP Context:

```typescript
const httpContext = context.switchToHttp();
const request = httpContext.getRequest<Request>();
const response = httpContext.getResponse<Response>();
const next = httpContext.getNext();

// Request details
const method = request.method;
const url = request.url;
const headers = request.headers;
const body = request.body;
const params = request.params;
const query = request.query;
```

### WebSocket Context:

```typescript
const wsContext = context.switchToWs();
const client = wsContext.getClient(); // Socket client
const data = wsContext.getData(); // Incoming message data
```

### RPC Context:

```typescript
const rpcContext = context.switchToRpc();
const data = rpcContext.getData(); // RPC data
const rpcContext = rpcContext.getContext(); // RPC context
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪৬. @Res() ডেকোরেটরের উদ্দেশ্য

`@Res()` response object সরাসরি অ্যাক্সেস করতে ব্যবহৃত হয়।

### Basic ব্যবহার:

```typescript
import { Controller, Get, Res } from "@nestjs/common";
import { Response } from "express";

@Controller("users")
export class UsersController {
	@Get()
	findAll(@Res() res: Response) {
		return res.status(200).json({ message: "Success", data: [] });
	}
}
```

**সতর্কতা:** `@Res()` ব্যবহার করলে NestJS এর standard response handling বন্ধ হয়ে যায়।

### passthrough mode:

```typescript
@Get()
findAll(@Res({ passthrough: true }) res: Response) {
  res.cookie('token', 'value');
  return { message: 'Success' }; // NestJS এটি serialize করবে
}
```

### File Download:

```typescript
@Get("download")
downloadFile(@Res() res: Response) {
	const file = path.join(__dirname, "..", "files", "document.pdf");
	res.download(file);
}
```

### Streaming Response:

```typescript
@Get("stream")
streamData(@Res() res: Response) {
	const stream = fs.createReadStream("large-file.txt");
	stream.pipe(res);
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪৭. বিভিন্ন প্রকার Modules

### Feature Modules:

```typescript
@Module({
	controllers: [UsersController],
	providers: [UsersService],
	exports: [UsersService],
})
export class UsersModule {}
```

### Shared Modules:

```typescript
@Module({
	providers: [DatabaseService],
	exports: [DatabaseService],
})
export class DatabaseModule {}

// অন্য module এ import
@Module({
	imports: [DatabaseModule],
})
export class UsersModule {}
```

### Global Modules:

```typescript
import { Global, Module } from "@nestjs/common";

@Global()
@Module({
	providers: [LoggerService],
	exports: [LoggerService],
})
export class LoggerModule {}
```

### Dynamic Modules:

```typescript
@Module({})
export class ConfigModule {
	static forRoot(options: ConfigModuleOptions): DynamicModule {
		return {
			module: ConfigModule,
			providers: [
				{
					provide: "CONFIG_OPTIONS",
					useValue: options,
				},
				ConfigService,
			],
			exports: [ConfigService],
		};
	}
}

// ব্যবহার
@Module({
	imports: [ConfigModule.forRoot({ folder: "./config" })],
})
export class AppModule {}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪৮. NestJS অ্যাপ্লিকেশন সুরক্ষিত করা

### Helmet ব্যবহার:

```bash
npm install helmet
```

```typescript
import helmet from "helmet";

async function bootstrap() {
	const app = await NestFactory.create(AppModule);
	app.use(helmet());
	await app.listen(3000);
}
```

### Rate Limiting:

```bash
npm install @nestjs/throttler
```

```typescript
import { ThrottlerModule } from "@nestjs/throttler";

@Module({
	imports: [
		ThrottlerModule.forRoot({
			ttl: 60,
			limit: 10,
		}),
	],
})
export class AppModule {}
```

### Input Validation:

```typescript
app.useGlobalPipes(
	new ValidationPipe({
		whitelist: true, // শুধুমাত্র DTO তে থাকা properties
		forbidNonWhitelisted: true, // অতিরিক্ত properties reject
		transform: true, // Auto type conversion
	}),
);
```

### CSRF Protection:

```bash
npm install csurf
```

```typescript
import * as csurf from "csurf";
app.use(csurf());
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৪৯. Entry File (main.ts)

`main.ts` হল NestJS অ্যাপ্লিকেশনের এন্ট্রি পয়েন্ট।

```typescript
import { NestFactory } from "@nestjs/core";
import { ValidationPipe } from "@nestjs/common";
import { SwaggerModule, DocumentBuilder } from "@nestjs/swagger";
import { AppModule } from "./app.module";

async function bootstrap() {
	const app = await NestFactory.create(AppModule, {
		logger: ["error", "warn", "log"],
	});

	// Global prefix
	app.setGlobalPrefix("api/v1");

	// CORS
	app.enableCors();

	// Validation
	app.useGlobalPipes(new ValidationPipe());

	// Swagger
	const config = new DocumentBuilder().setTitle("API").setVersion("1.0").build();
	const document = SwaggerModule.createDocument(app, config);
	SwaggerModule.setup("docs", app, document);

	await app.listen(process.env.PORT || 3000);
}
bootstrap();
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫০. Dependency Injection vs Inversion of Control

**Inversion of Control (IoC):** একটি সাধারণ নীতি যেখানে control flow উল্টানো হয়।

**Dependency Injection (DI):** IoC এর একটি নির্দিষ্ট বাস্তবায়ন।

### পার্থক্য:

| Aspect | IoC | DI |
|--------|-----|-----|
| স্তর | নীতি/প্যাটার্ন | বাস্তবায়ন কৌশল |
| সুযোগ | Framework control | Object creation |
| উদাহরণ | Event handling, callbacks | Constructor injection |

```typescript
// IoC উদাহরণ: Framework control flow নিয়ন্ত্রণ করে
@Controller()
class AppController {
	@Get() // Framework এটি কখন কল করবে নির্ধারণ করে
	getHello() {
		return "Hello";
	}
}

// DI উদাহরণ: Dependencies inject করা হয়
@Injectable()
class UserService {
	constructor(private db: DatabaseService) {} // DI এখানে
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**


## ৫১. Caching Implementation

Caching পারফরম্যান্স উন্নত করতে ডেটা temporarily সংরক্ষণ করে।

### ইনস্টলেশন:

```bash
npm install @nestjs/cache-manager cache-manager
```

### Cache Module সেটআপ:

```typescript
import { CacheModule } from "@nestjs/cache-manager";

@Module({
	imports: [
		CacheModule.register({
			ttl: 5, // seconds
			max: 100, // maximum items
		}),
	],
})
export class AppModule {}
```

### Cache ব্যবহার:

```typescript
import { CACHE_MANAGER } from "@nestjs/cache-manager";
import { Cache } from "cache-manager";

@Injectable()
export class UsersService {
	constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}

	async getUsers(): Promise<User[]> {
		const cachedUsers = await this.cacheManager.get<User[]>("users");

		if (cachedUsers) {
			return cachedUsers;
		}

		const users = await this.usersRepository.find();
		await this.cacheManager.set("users", users, 600); // 10 minutes
		return users;
	}

	async clearCache(): Promise<void> {
		await this.cacheManager.reset();
	}
}
```

### CacheInterceptor ব্যবহার:

```typescript
import { CacheInterceptor, UseInterceptors } from "@nestjs/common";

@Controller("users")
@UseInterceptors(CacheInterceptor)
export class UsersController {
	@Get()
	findAll() {
		return this.usersService.findAll();
	}
}
```

### Redis Cache:

```bash
npm install cache-manager-redis-store
```

```typescript
import * as redisStore from "cache-manager-redis-store";

CacheModule.register({
	store: redisStore,
	host: "localhost",
	port: 6379,
	ttl: 600,
});
```

### কাস্টম Cache Key:

```typescript
@CacheKey("custom_users")
@Get()
findAll() {
  return this.usersService.findAll();
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫২. Dependency Inversion Principle (DIP)

DIP SOLID principles এর একটি, যা abstraction এর উপর নির্ভরতা শেখায়।

### নীতি:
1. High-level modules low-level modules এর উপর নির্ভর করবে না
2. উভয়ই abstractions এর উপর নির্ভর করবে

### খারাপ উদাহরণ (DIP লঙ্ঘন):

```typescript
class MySQLDatabase {
	connect() {
		console.log("MySQL connected");
	}
}

class UserService {
	private db = new MySQLDatabase(); // Concrete class এর উপর নির্ভরশীল

	getUsers() {
		this.db.connect();
		// ...
	}
}
```

### ভালো উদাহরণ (DIP অনুসরণ):

```typescript
// Abstraction (Interface)
interface IDatabase {
	connect(): void;
	query(sql: string): Promise<any>;
}

// Low-level module
@Injectable()
class MySQLDatabase implements IDatabase {
	connect() {
		console.log("MySQL connected");
	}

	query(sql: string) {
		return Promise.resolve([]);
	}
}

// High-level module
@Injectable()
class UserService {
	constructor(@Inject("IDatabase") private db: IDatabase) {}

	async getUsers() {
		await this.db.connect();
		return this.db.query("SELECT * FROM users");
	}
}

// Module configuration
@Module({
	providers: [
		{
			provide: "IDatabase",
			useClass: MySQLDatabase,
		},
		UserService,
	],
})
export class AppModule {}
```

### একাধিক Implementation:

```typescript
class PostgreSQLDatabase implements IDatabase {
	connect() {
		console.log("PostgreSQL connected");
	}

	query(sql: string) {
		return Promise.resolve([]);
	}
}

// Environment ভিত্তিক selection
const databaseProvider = {
	provide: "IDatabase",
	useClass: process.env.DB_TYPE === "postgres" ? PostgreSQLDatabase : MySQLDatabase,
};
```

**সুবিধা:**
- Flexible এবং maintainable code
- Easy testing (mock করা সহজ)
- Loose coupling
- Implementation পরিবর্তন সহজ

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫৩. Task Scheduling

Task scheduling নির্দিষ্ট সময়ে কাজ স্বয়ংক্রিয়ভাবে চালানোর জন্য ব্যবহৃত হয়।

### ইনস্টলেশন:

```bash
npm install @nestjs/schedule
```

### ScheduleModule সেটআপ:

```typescript
import { ScheduleModule } from "@nestjs/schedule";

@Module({
	imports: [ScheduleModule.forRoot()],
})
export class AppModule {}
```

### Cron Jobs:

```typescript
import { Injectable } from "@nestjs/common";
import { Cron, CronExpression } from "@nestjs/schedule";

@Injectable()
export class TasksService {
	// প্রতি 10 সেকেন্ডে
	@Cron("*/10 * * * * *")
	handleCron() {
		console.log("প্রতি 10 সেকেন্ডে চলছে");
	}

	// প্রতিদিন মধ্যরাতে
	@Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
	handleMidnight() {
		console.log("মধ্যরাতে চলছে");
	}

	// প্রতি সোমবার সকাল 9টায়
	@Cron("0 9 * * 1")
	handleMonday() {
		console.log("প্রতি সোমবার 9AM");
	}
}
```

### Interval Tasks:

```typescript
import { Interval } from "@nestjs/schedule";

@Interval(10000) // 10 seconds
handleInterval() {
  console.log('প্রতি 10 সেকেন্ডে');
}
```

### Timeout Tasks:

```typescript
import { Timeout } from "@nestjs/schedule";

@Timeout(5000) // 5 seconds after app starts
handleTimeout() {
  console.log('অ্যাপ শুরুর 5 সেকেন্ড পর');
}
```

### Dynamic Cron:

```typescript
import { SchedulerRegistry } from "@nestjs/schedule";
import { CronJob } from "cron";

@Injectable()
export class TasksService {
	constructor(private schedulerRegistry: SchedulerRegistry) {}

	addCronJob(name: string, seconds: string) {
		const job = new CronJob(`${seconds} * * * * *`, () => {
			console.log(`${name} চলছে`);
		});

		this.schedulerRegistry.addCronJob(name, job);
		job.start();
	}

	deleteCronJob(name: string) {
		this.schedulerRegistry.deleteCronJob(name);
	}

	getCronJobs() {
		const jobs = this.schedulerRegistry.getCronJobs();
		jobs.forEach((value, key) => {
			console.log(`Job: ${key}, Next: ${value.nextDate()}`);
		});
	}
}
```

### Cron Expressions:

```typescript
@Cron("0 0 * * *") // প্রতিদিন মধ্যরাতে
@Cron("0 */6 * * *") // প্রতি 6 ঘণ্টায়
@Cron("0 9-17 * * 1-5") // সোম-শুক্র 9AM-5PM
@Cron("0 0 1 * *") // প্রতি মাসের 1 তারিখে
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫৪. Database Transactions

Transactions নিশ্চিত করে যে সব operations সফল হবে অথবা কোনটিই হবে না।

### TypeORM Transaction:

```typescript
import { DataSource } from "typeorm";

@Injectable()
export class UsersService {
	constructor(private dataSource: DataSource) {}

	async createUserWithProfile(userData: any, profileData: any) {
		const queryRunner = this.dataSource.createQueryRunner();

		await queryRunner.connect();
		await queryRunner.startTransaction();

		try {
			// User তৈরি
			const user = await queryRunner.manager.save(User, userData);

			// Profile তৈরি
			profileData.userId = user.id;
			await queryRunner.manager.save(Profile, profileData);

			// Transaction commit
			await queryRunner.commitTransaction();

			return user;
		} catch (err) {
			// Error হলে rollback
			await queryRunner.rollbackTransaction();
			throw err;
		} finally {
			// QueryRunner release
			await queryRunner.release();
		}
	}
}
```

### Transaction Decorator:

```typescript
import { Transaction, TransactionManager, EntityManager } from "typeorm";

@Transaction()
async createUserWithProfile(
	userData: any,
	profileData: any,
	@TransactionManager() manager: EntityManager,
) {
	const user = await manager.save(User, userData);
	profileData.userId = user.id;
	await manager.save(Profile, profileData);
	return user;
}
```

### Nested Transactions:

```typescript
async complexOperation() {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();

  try {
    await queryRunner.manager.save(User, userData);
    
    // Nested transaction
    await queryRunner.startTransaction("nested");
    try {
      await queryRunner.manager.save(Profile, profileData);
      await queryRunner.commitTransaction("nested");
    } catch (err) {
      await queryRunner.rollbackTransaction("nested");
      throw err;
    }

    await queryRunner.commitTransaction();
  } catch (err) {
    await queryRunner.rollbackTransaction();
    throw err;
  } finally {
    await queryRunner.release();
  }
}
```

### Isolation Levels:

```typescript
await queryRunner.startTransaction("READ COMMITTED");
// বা
await queryRunner.startTransaction("SERIALIZABLE");
```

**কেন Transactions গুরুত্বপূর্ণ:**
- Data consistency
- ACID properties নিশ্চিত করা
- Multiple operations atomically চালানো
- Error recovery

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫৫. API Versioning

API versioning বিভিন্ন version একসাথে চালাতে দেয়।

### URI Versioning:

```typescript
import { VersioningType } from "@nestjs/common";

async function bootstrap() {
	const app = await NestFactory.create(AppModule);

	app.enableVersioning({
		type: VersioningType.URI,
	});

	await app.listen(3000);
}
```

```typescript
@Controller({
	path: "users",
	version: "1",
})
export class UsersV1Controller {
	@Get()
	findAll() {
		return "Version 1";
	}
}

@Controller({
	path: "users",
	version: "2",
})
export class UsersV2Controller {
	@Get()
	findAll() {
		return "Version 2";
	}
}

// URLs: /v1/users, /v2/users
```

### Header Versioning:

```typescript
app.enableVersioning({
	type: VersioningType.HEADER,
	header: "X-API-Version",
});

// Request: X-API-Version: 1
```

### Media Type Versioning:

```typescript
app.enableVersioning({
	type: VersioningType.MEDIA_TYPE,
	key: "v=",
});

// Request: Accept: application/json;v=1
```

### Multiple Versions:

```typescript
@Controller({
	path: "users",
	version: ["1", "2"],
})
export class UsersController {
	@Get()
	findAll(@Version() version: string) {
		return `Version ${version}`;
	}
}
```

### Version-specific Routes:

```typescript
@Controller("users")
export class UsersController {
	@Version("1")
	@Get()
	findAllV1() {
		return "V1 users";
	}

	@Version("2")
	@Get()
	findAllV2() {
		return "V2 users";
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫৬. GraphQL Resolver এবং Scalar

### GraphQL সেটআপ:

```bash
npm install @nestjs/graphql @nestjs/apollo graphql apollo-server-express
```

```typescript
import { GraphQLModule } from "@nestjs/graphql";
import { ApolloDriver, ApolloDriverConfig } from "@nestjs/apollo";

@Module({
	imports: [
		GraphQLModule.forRoot<ApolloDriverConfig>({
			driver: ApolloDriver,
			autoSchemaFile: "schema.gql",
		}),
	],
})
export class AppModule {}
```

### Resolver:

```typescript
import { Resolver, Query, Mutation, Args } from "@nestjs/graphql";

@Resolver("User")
export class UsersResolver {
	constructor(private usersService: UsersService) {}

	@Query(() => [User])
	async users() {
		return this.usersService.findAll();
	}

	@Query(() => User)
	async user(@Args("id") id: number) {
		return this.usersService.findOne(id);
	}

	@Mutation(() => User)
	async createUser(@Args("createUserInput") input: CreateUserInput) {
		return this.usersService.create(input);
	}
}
```

### Object Type:

```typescript
import { ObjectType, Field, Int } from "@nestjs/graphql";

@ObjectType()
export class User {
	@Field(() => Int)
	id: number;

	@Field()
	email: string;

	@Field()
	name: string;

	@Field({ nullable: true })
	age?: number;
}
```

### Input Type:

```typescript
import { InputType, Field } from "@nestjs/graphql";

@InputType()
export class CreateUserInput {
	@Field()
	email: string;

	@Field()
	name: string;

	@Field({ nullable: true })
	age?: number;
}
```

### Custom Scalar:

```typescript
import { Scalar, CustomScalar } from "@nestjs/graphql";
import { Kind, ValueNode } from "graphql";

@Scalar("Date")
export class DateScalar implements CustomScalar<number, Date> {
	description = "Date custom scalar type";

	parseValue(value: number): Date {
		return new Date(value); // client থেকে আসা value
	}

	serialize(value: Date): number {
		return value.getTime(); // client এ পাঠানো value
	}

	parseLiteral(ast: ValueNode): Date {
		if (ast.kind === Kind.INT) {
			return new Date(ast.value);
		}
		return null;
	}
}
```

### Subscriptions:

```typescript
import { Subscription } from "@nestjs/graphql";
import { PubSub } from "graphql-subscriptions";

const pubSub = new PubSub();

@Resolver()
export class UsersResolver {
	@Subscription(() => User)
	userCreated() {
		return pubSub.asyncIterator("userCreated");
	}

	@Mutation(() => User)
	async createUser(@Args("input") input: CreateUserInput) {
		const user = await this.usersService.create(input);
		pubSub.publish("userCreated", { userCreated: user });
		return user;
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫৭. Serialization এবং Deserialization

### Serialization (Object → JSON):

```typescript
import { Exclude, Expose, Transform } from "class-transformer";

export class UserEntity {
	id: number;

	email: string;

	@Exclude() // Response এ দেখাবে না
	password: string;

	@Expose({ name: "fullName" }) // Rename করা
	name: string;

	@Transform(({ value }) => value.toUpperCase())
	role: string;

	constructor(partial: Partial<UserEntity>) {
		Object.assign(this, partial);
	}
}
```

### ClassSerializerInterceptor:

```typescript
import { ClassSerializerInterceptor, UseInterceptors } from "@nestjs/common";

@Controller("users")
export class UsersController {
	@UseInterceptors(ClassSerializerInterceptor)
	@Get()
	findAll() {
		return this.usersService.findAll().map((user) => new UserEntity(user));
	}
}
```

### Global Serialization:

```typescript
// main.ts
app.useGlobalInterceptors(new ClassSerializerInterceptor(app.get(Reflector)));
```

### Groups:

```typescript
import { Expose } from "class-transformer";

export class UserEntity {
	@Expose({ groups: ["admin"] })
	id: number;

	@Expose({ groups: ["user", "admin"] })
	email: string;

	@Expose({ groups: ["admin"] })
	sensitiveData: string;
}

// Controller এ
@SerializeOptions({ groups: ["user"] })
@Get()
findAll() {
  return users;
}
```

### Custom Transformation:

```typescript
@Transform(({ value }) => {
  return value ? new Date(value).toISOString() : null;
})
createdAt: Date;
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫৮. Microservices এ Middleware

Microservices architecture এ middleware request processing, authentication, logging ইত্যাদিতে সাহায্য করে।

### HTTP Microservice Middleware:

```typescript
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
	use(req: Request, res: Response, next: NextFunction) {
		console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
		next();
	}
}
```

### Microservice-specific Middleware:

```typescript
import { Injectable, NestMiddleware } from "@nestjs/common";

@Injectable()
export class AuthenticationMiddleware implements NestMiddleware {
	async use(req: any, res: any, next: () => void) {
		const token = req.headers.authorization?.split(" ")[1];

		if (!token) {
			throw new UnauthorizedException();
		}

		try {
			const decoded = await this.verifyToken(token);
			req.user = decoded;
			next();
		} catch (error) {
			throw new UnauthorizedException("Invalid token");
		}
	}

	private async verifyToken(token: string) {
		// JWT verification logic
		return {};
	}
}
```

### Inter-service Communication Middleware:

```typescript
@Injectable()
export class ServiceTrackerMiddleware implements NestMiddleware {
	use(req: Request, res: Response, next: NextFunction) {
		const serviceId = req.headers["x-service-id"];
		const requestId = req.headers["x-request-id"] || generateUUID();

		req.headers["x-request-id"] = requestId;

		console.log(`Request from service: ${serviceId}, Request ID: ${requestId}`);

		next();
	}
}
```

**উপকারী scenarios:**
- Distributed tracing
- Service authentication
- Request/response logging
- Rate limiting per service
- Circuit breaker pattern

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৫৯. Tight vs Loose Coupling

### Tight Coupling (খারাপ):

```typescript
class EmailService {
	sendEmail(to: string, message: string) {
		console.log(`Email sent to ${to}`);
	}
}

class UserService {
	private emailService = new EmailService(); // Tightly coupled

	createUser(userData: any) {
		// User তৈরি
		this.emailService.sendEmail(userData.email, "Welcome");
	}
}
```

**সমস্যা:**
- EmailService পরিবর্তন করা কঠিন
- Testing কঠিন (mock করা যায় না)
- Flexibility কম

### Loose Coupling (ভালো):

```typescript
// Interface
interface INotificationService {
	send(to: string, message: string): void;
}

// Implementations
@Injectable()
class EmailService implements INotificationService {
	send(to: string, message: string) {
		console.log(`Email: ${to}`);
	}
}

@Injectable()
class SMSService implements INotificationService {
	send(to: string, message: string) {
		console.log(`SMS: ${to}`);
	}
}

// UserService depends on abstraction
@Injectable()
class UserService {
	constructor(
		@Inject("INotificationService")
		private notificationService: INotificationService,
	) {}

	createUser(userData: any) {
		// User তৈরি
		this.notificationService.send(userData.email, "Welcome");
	}
}

// Module configuration
@Module({
	providers: [
		{
			provide: "INotificationService",
			useClass: EmailService, // সহজেই পরিবর্তন করা যায়
		},
		UserService,
	],
})
export class UsersModule {}
```

**সুবিধা:**
- সহজে testing
- Implementation পরিবর্তন সহজ
- Maintainable code
- Flexibility

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬০. Server-Sent Events (SSE)

SSE সার্ভার থেকে client এ real-time updates পাঠাতে ব্যবহৃত হয়।

### Basic SSE:

```typescript
import { Sse } from "@nestjs/common";
import { Observable, interval } from "rxjs";
import { map } from "rxjs/operators";

@Controller("events")
export class EventsController {
	@Sse("stream")
	stream(): Observable<MessageEvent> {
		return interval(1000).pipe(
			map((num) => ({
				data: { message: `Update ${num}` },
			})),
		);
	}
}
```

### Custom Event Type:

```typescript
interface MessageEvent {
	data: string | object;
	id?: string;
	type?: string;
	retry?: number;
}

@Sse("notifications")
notifications(): Observable<MessageEvent> {
  return this.notificationService.getStream().pipe(
    map(notification => ({
      data: notification,
      type: 'notification',
      id: notification.id,
      retry: 10000
    }))
  );
}
```

### Client-side (Browser):

```javascript
const eventSource = new EventSource("http://localhost:3000/events/stream");

eventSource.onmessage = (event) => {
	console.log("নতুন message:", JSON.parse(event.data));
};

eventSource.addEventListener("notification", (event) => {
	console.log("Notification:", event.data);
});

eventSource.onerror = (error) => {
	console.error("Error:", error);
};
```

### Real-time Stock Updates উদাহরণ:

```typescript
@Injectable()
export class StockService {
	private stocks$ = new Subject<Stock>();

	@Sse("stocks")
	streamStocks(): Observable<MessageEvent> {
		return this.stocks$.pipe(
			map((stock) => ({
				data: {
					symbol: stock.symbol,
					price: stock.price,
					timestamp: new Date().toISOString(),
				},
			})),
		);
	}

	updateStock(stock: Stock) {
		this.stocks$.next(stock);
	}
}
```

**SSE এর সুবিধা:**
- HTTP এর উপর নির্মিত (firewall friendly)
- Automatic reconnection
- Event IDs (missed events পেতে)
- Simple implementation
- Built-in browser support

**কখন ব্যবহার করবেন:**
- Live notifications
- Stock price updates
- Real-time analytics
- Live feeds (Twitter, news)
- Progress updates

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**


## উন্নত প্রশ্ন (৮+ বছরের অভিজ্ঞতার জন্য)

## ৬১. Custom Provider এর বিভিন্ন উপায় (useClass, useValue, useFactory, useExisting)

### useValue Provider:

```typescript
const configProvider = {
	provide: "CONFIG",
	useValue: {
		apiKey: "my-api-key",
		apiUrl: "https://api.example.com",
		timeout: 5000,
	},
};

@Module({
	providers: [configProvider],
})
export class AppModule {}

// ব্যবহার
@Injectable()
export class ApiService {
	constructor(@Inject("CONFIG") private config: any) {
		console.log(this.config.apiKey);
	}
}
```

### useClass Provider:

```typescript
// Interface
abstract class Logger {
	abstract log(message: string): void;
}

// Implementations
class DevLogger extends Logger {
	log(message: string) {
		console.log(`[DEV] ${message}`);
	}
}

class ProdLogger extends Logger {
	log(message: string) {
		// Send to external service
		console.log(`[PROD] ${message}`);
	}
}

// Provider
const loggerProvider = {
	provide: Logger,
	useClass: process.env.NODE_ENV === "production" ? ProdLogger : DevLogger,
};
```

### useFactory Provider:

```typescript
const databaseProvider = {
	provide: "DATABASE_CONNECTION",
	useFactory: async (configService: ConfigService) => {
		const options = {
			host: configService.get("DB_HOST"),
			port: configService.get("DB_PORT"),
		};
		const connection = await createConnection(options);
		return connection;
	},
	inject: [ConfigService], // Dependencies
};
```

### useFactory with Async:

```typescript
const asyncProvider = {
	provide: "ASYNC_VALUE",
	useFactory: async () => {
		await new Promise((resolve) => setTimeout(resolve, 1000));
		return { initialized: true };
	},
};
```

### useExisting Provider (Alias):

```typescript
@Injectable()
class LoggerService {
	log(message: string) {
		console.log(message);
	}
}

const aliasProvider = {
	provide: "Logger",
	useExisting: LoggerService,
};

@Module({
	providers: [LoggerService, aliasProvider],
})
export class AppModule {}

// এখন উভয়ই একই instance ব্যবহার করবে
@Injectable()
class Service1 {
	constructor(private logger: LoggerService) {}
}

@Injectable()
class Service2 {
	constructor(@Inject("Logger") private logger: LoggerService) {}
}
```

### Advanced Factory Pattern:

```typescript
const complexProvider = {
	provide: "COMPLEX_SERVICE",
	useFactory: (
		config: ConfigService,
		logger: Logger,
		cache: Cache,
	) => {
		if (config.get("USE_CACHE")) {
			return new CachedService(logger, cache);
		}
		return new RegularService(logger);
	},
	inject: [ConfigService, Logger, CACHE_MANAGER],
};
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬২. Optional Providers

Optional providers যেগুলো না থাকলেও অ্যাপ্লিকেশন চলবে।

### @Optional() Decorator:

```typescript
import { Optional, Injectable } from "@nestjs/common";

@Injectable()
export class HttpService {
	constructor(
		@Optional() private logger?: Logger, // Optional
	) {
		this.logger?.log("HttpService initialized");
	}

	get(url: string) {
		this.logger?.log(`GET ${url}`);
		// ... rest of the code
	}
}
```

### Optional with Inject:

```typescript
@Injectable()
export class ApiService {
	constructor(
		@Optional()
		@Inject("API_CONFIG")
		private config?: ApiConfig,
	) {
		const apiKey = this.config?.apiKey || "default-key";
	}
}
```

### Conditional Provider:

```typescript
const cacheProvider = {
	provide: "CACHE",
	useFactory: (config: ConfigService) => {
		if (config.get("ENABLE_CACHE")) {
			return new Redis();
		}
		return null;
	},
	inject: [ConfigService],
};

@Injectable()
export class UserService {
	constructor(@Optional() @Inject("CACHE") private cache?: Redis) {}

	async getUser(id: number) {
		if (this.cache) {
			const cached = await this.cache.get(`user:${id}`);
			if (cached) return cached;
		}
		// Fetch from database
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬৩. Property-based vs Constructor-based Injection

### Constructor-based Injection (প্রস্তাবিত):

```typescript
@Injectable()
export class UserService {
	constructor(
		private readonly userRepository: Repository<User>,
		private readonly emailService: EmailService,
	) {}

	async createUser(data: CreateUserDto) {
		const user = await this.userRepository.save(data);
		await this.emailService.send(user.email);
		return user;
	}
}
```

**সুবিধা:**
- Dependencies স্পষ্ট
- Immutable (readonly ব্যবহার করা যায়)
- Testing সহজ
- Type safety

### Property-based Injection:

```typescript
import { Inject } from "@nestjs/common";

@Injectable()
export class UserService {
	@Inject()
	private readonly userRepository: Repository<User>;

	@Inject()
	private readonly emailService: EmailService;

	async createUser(data: CreateUserDto) {
		const user = await this.userRepository.save(data);
		await this.emailService.send(user.email);
		return user;
	}
}
```

**কখন Property-based ব্যবহার করবেন:**
- Circular dependency এড়াতে
- অনেক বেশি dependencies
- Base class এ

### Circular Dependency সমাধানে:

```typescript
@Injectable()
export class CatsService {
	@Inject(forwardRef(() => DogsService))
	private dogsService: DogsService;

	getCats() {
		return this.dogsService.getDogs();
	}
}
```

### তুলনা:

| Feature | Constructor | Property |
|---------|-------------|----------|
| স্পষ্টতা | ✅ High | ⚠️ Medium |
| Immutability | ✅ Yes (readonly) | ❌ No |
| Testing | ✅ Easy | ⚠️ Medium |
| Circular deps | ⚠️ Needs forwardRef | ✅ Easier |

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬৪. Scoped Providers (DEFAULT, REQUEST, TRANSIENT)

### DEFAULT Scope (Singleton):

```typescript
@Injectable() // ডিফল্ট
export class UserService {
	// অ্যাপ্লিকেশনে একটিমাত্র instance
}
```

### REQUEST Scope:

```typescript
import { Injectable, Scope } from "@nestjs/common";

@Injectable({ scope: Scope.REQUEST })
export class RequestScopedService {
	// প্রতিটি request এর জন্য নতুন instance
	private requestData: any;

	setData(data: any) {
		this.requestData = data;
	}

	getData() {
		return this.requestData;
	}
}
```

### REQUEST Scope এ Request অবজেক্ট inject:

```typescript
import { Inject, Injectable, Scope } from "@nestjs/common";
import { REQUEST } from "@nestjs/core";
import { Request } from "express";

@Injectable({ scope: Scope.REQUEST })
export class AuditService {
	constructor(@Inject(REQUEST) private request: Request) {}

	log(action: string) {
		const user = this.request.user;
		const ip = this.request.ip;
		console.log(`${user} performed ${action} from ${ip}`);
	}
}
```

### TRANSIENT Scope:

```typescript
@Injectable({ scope: Scope.TRANSIENT })
export class TransientService {
	// প্রতিবার inject করার সময় নতুন instance
	private id = Math.random();

	getId() {
		return this.id;
	}
}
```

### Controller এ Scope:

```typescript
@Controller({
	path: "users",
	scope: Scope.REQUEST,
})
export class UsersController {
	// প্রতি request এ নতুন controller instance
}
```

### Provider Scope তুলনা:

| Scope | Lifetime | Use Case |
|-------|----------|----------|
| DEFAULT | Application | সাধারণ services |
| REQUEST | Per request | Request-specific data |
| TRANSIENT | Per injection | Unique instances |

### Performance বিবেচনা:

```typescript
// Performance: DEFAULT > REQUEST > TRANSIENT
// DEFAULT - সবচেয়ে fast (singleton)
// REQUEST - প্রতি request এ overhead
// TRANSIENT - সবচেয়ে বেশি overhead
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬৫. Hierarchical Injector এবং Module Reference

### Module Reference:

```typescript
import { ModuleRef } from "@nestjs/core";

@Injectable()
export class DynamicService {
	constructor(private moduleRef: ModuleRef) {}

	async getServiceDynamically() {
		// Runtime এ service পেতে
		const userService = this.moduleRef.get(UserService, { strict: false });
		return userService.findAll();
	}

	async getByToken() {
		const config = this.moduleRef.get("CONFIG");
		return config;
	}
}
```

### Hierarchical Injection:

```typescript
@Module({
	providers: [
		{
			provide: "LOGGER_PREFIX",
			useValue: "APP",
		},
		LoggerService,
	],
	exports: [LoggerService],
})
export class AppModule {}

@Module({
	imports: [AppModule],
	providers: [
		{
			provide: "LOGGER_PREFIX",
			useValue: "USER_MODULE", // Override করা
		},
	],
})
export class UserModule {}
```

### Request-scoped Provider Resolution:

```typescript
@Injectable({ scope: Scope.REQUEST })
export class RequestService {
	constructor(private moduleRef: ModuleRef) {}

	async resolveProvider() {
		// Context-aware resolution
		const contextId = ContextIdFactory.create();
		const userService = await this.moduleRef.resolve(UserService, contextId);
		return userService;
	}
}
```

### LazyModuleLoader:

```typescript
import { LazyModuleLoader } from "@nestjs/core";

@Injectable()
export class AppService {
	constructor(private lazyModuleLoader: LazyModuleLoader) {}

	async loadLazyModule() {
		const { LazyModule } = await import("./lazy.module");
		const moduleRef = await this.lazyModuleLoader.load(() => LazyModule);

		const { LazyService } = await import("./lazy.service");
		const lazyService = moduleRef.get(LazyService);

		return lazyService.doSomething();
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬৬. Asynchronous Providers

Asynchronous providers যেগুলো async operation সম্পন্ন হওয়ার পর available হয়।

### useFactory with Async:

```typescript
const databaseProvider = {
	provide: "DATABASE_CONNECTION",
	useFactory: async () => {
		const connection = await createConnection({
			type: "mongodb",
			url: "mongodb://localhost:27017/nest",
		});
		return connection;
	},
};
```

### Dependency সহ Async Provider:

```typescript
const asyncProvider = {
	provide: "ASYNC_SERVICE",
	useFactory: async (configService: ConfigService) => {
		const apiKey = configService.get("API_KEY");
		const client = await initializeClient(apiKey);
		return client;
	},
	inject: [ConfigService],
};
```

### useClass with Async:

```typescript
@Injectable()
export class AsyncConfigService {
	private config: any;

	async onModuleInit() {
		// Module initialization এ async operation
		this.config = await this.loadConfigFromRemote();
	}

	private async loadConfigFromRemote() {
		const response = await fetch("https://config-server.com/config");
		return response.json();
	}

	get(key: string) {
		return this.config[key];
	}
}
```

### Multiple Async Dependencies:

```typescript
const complexAsyncProvider = {
	provide: "COMPLEX_SERVICE",
	useFactory: async (db: Database, cache: Cache, config: Config) => {
		await db.connect();
		await cache.connect();

		const settings = await config.load();

		return new ComplexService(db, cache, settings);
	},
	inject: ["DATABASE", "CACHE", ConfigService],
};
```

### Async Module forRootAsync:

```typescript
@Module({})
export class ConfigModule {
	static forRootAsync(options: ConfigModuleAsyncOptions): DynamicModule {
		return {
			module: ConfigModule,
			imports: options.imports || [],
			providers: [
				{
					provide: "CONFIG_OPTIONS",
					useFactory: options.useFactory,
					inject: options.inject || [],
				},
				ConfigService,
			],
			exports: [ConfigService],
		};
	}
}

// ব্যবহার
@Module({
	imports: [
		ConfigModule.forRootAsync({
			imports: [HttpModule],
			useFactory: async (httpService: HttpService) => {
				const config = await httpService.get("https://config-api.com").toPromise();
				return config.data;
			},
			inject: [HttpService],
		}),
	],
})
export class AppModule {}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬৭. Dynamic Modules

Dynamic modules runtime এ configuration সহ module তৈরি করে।

### Basic Dynamic Module:

```typescript
@Module({})
export class DatabaseModule {
	static forRoot(options: DatabaseOptions): DynamicModule {
		return {
			module: DatabaseModule,
			providers: [
				{
					provide: "DATABASE_OPTIONS",
					useValue: options,
				},
				DatabaseService,
			],
			exports: [DatabaseService],
		};
	}
}

// ব্যবহার
@Module({
	imports: [
		DatabaseModule.forRoot({
			host: "localhost",
			port: 5432,
		}),
	],
})
export class AppModule {}
```

### forRootAsync Pattern:

```typescript
interface DatabaseModuleAsyncOptions {
	imports?: any[];
	useFactory?: (...args: any[]) => Promise<DatabaseOptions> | DatabaseOptions;
	inject?: any[];
}

@Module({})
export class DatabaseModule {
	static forRootAsync(options: DatabaseModuleAsyncOptions): DynamicModule {
		return {
			module: DatabaseModule,
			imports: options.imports || [],
			providers: [
				{
					provide: "DATABASE_OPTIONS",
					useFactory: options.useFactory,
					inject: options.inject || [],
				},
				DatabaseService,
			],
			exports: [DatabaseService],
		};
	}
}
```

### Global Dynamic Module:

```typescript
@Global()
@Module({})
export class GlobalCacheModule {
	static forRoot(options: CacheOptions): DynamicModule {
		return {
			global: true,
			module: GlobalCacheModule,
			providers: [
				{
					provide: "CACHE_OPTIONS",
					useValue: options,
				},
				CacheService,
			],
			exports: [CacheService],
		};
	}
}
```

### Configurable Module Builder:

```typescript
import { ConfigurableModuleBuilder } from "@nestjs/common";

interface CacheModuleOptions {
	ttl: number;
	max: number;
}

const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } = new ConfigurableModuleBuilder<CacheModuleOptions>()
	.setClassMethodName("forRoot")
	.build();

@Module({})
export class CacheModule extends ConfigurableModuleClass {
	// Automatically provides forRoot() and forRootAsync()
}

@Injectable()
export class CacheService {
	constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: CacheModuleOptions) {
		console.log(`TTL: ${options.ttl}`);
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬৮. Multi-tenancy Implementation

Multi-tenancy একই অ্যাপ্লিকেশনে একাধিক tenants (organizations) সাপোর্ট করে।

### Database per Tenant:

```typescript
import { Inject, Injectable, Scope } from "@nestjs/common";
import { REQUEST } from "@nestjs/core";
import { Connection, createConnection } from "typeorm";

@Injectable({ scope: Scope.REQUEST })
export class TenantConnectionService {
	private connection: Connection;

	constructor(@Inject(REQUEST) private request: any) {}

	async getConnection(): Promise<Connection> {
		if (this.connection) {
			return this.connection;
		}

		const tenantId = this.request.headers["x-tenant-id"];

		this.connection = await createConnection({
			name: tenantId,
			type: "postgres",
			host: "localhost",
			port: 5432,
			database: `tenant_${tenantId}`,
			entities: [__dirname + "/**/*.entity{.ts,.js}"],
		});

		return this.connection;
	}
}
```

### Schema per Tenant:

```typescript
@Injectable({ scope: Scope.REQUEST })
export class TenantService {
	constructor(
		@Inject(REQUEST) private request: any,
		private dataSource: DataSource,
	) {}

	getTenantSchema(): string {
		const tenantId = this.request.headers["x-tenant-id"];
		return `tenant_${tenantId}`;
	}

	async query(sql: string): Promise<any> {
		const schema = this.getTenantSchema();
		return this.dataSource.query(`SET search_path TO ${schema}; ${sql}`);
	}
}
```

### Discriminator Column:

```typescript
@Entity("users")
export class User {
	@PrimaryGeneratedColumn()
	id: number;

	@Column()
	tenantId: string;

	@Column()
	name: string;
}

@Injectable()
export class UserService {
	constructor(
		@InjectRepository(User)
		private userRepository: Repository<User>,
	) {}

	async findByTenant(tenantId: string): Promise<User[]> {
		return this.userRepository.find({
			where: { tenantId },
		});
	}
}
```

### Tenant Middleware:

```typescript
@Injectable()
export class TenantMiddleware implements NestMiddleware {
	use(req: Request, res: Response, next: NextFunction) {
		const tenantId = this.extractTenantId(req);

		if (!tenantId) {
			throw new BadRequestException("Tenant ID not provided");
		}

		req["tenantId"] = tenantId;
		next();
	}

	private extractTenantId(req: Request): string {
		// From header
		if (req.headers["x-tenant-id"]) {
			return req.headers["x-tenant-id"] as string;
		}

		// From subdomain
		const host = req.headers.host;
		const subdomain = host?.split(".")[0];
		return subdomain;

		// From JWT token
		// const token = req.headers.authorization;
		// const decoded = jwt.verify(token);
		// return decoded.tenantId;
	}
}
```

### Tenant Guard:

```typescript
@Injectable()
export class TenantGuard implements CanActivate {
	canActivate(context: ExecutionContext): boolean {
		const request = context.switchToHttp().getRequest();
		const tenantId = request.tenantId;
		const user = request.user;

		if (user.tenantId !== tenantId) {
			throw new ForbiddenException("Access denied to this tenant");
		}

		return true;
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৬৯. CQRS Pattern

CQRS (Command Query Responsibility Segregation) read এবং write operations আলাদা করে।

### ইনস্টলেশন:

```bash
npm install @nestjs/cqrs
```

### Commands (Write):

```typescript
// create-user.command.ts
export class CreateUserCommand {
	constructor(
		public readonly email: string,
		public readonly name: string,
	) {}
}

// create-user.handler.ts
import { CommandHandler, ICommandHandler } from "@nestjs/cqrs";

@CommandHandler(CreateUserCommand)
export class CreateUserHandler implements ICommandHandler<CreateUserCommand> {
	constructor(private userRepository: UserRepository) {}

	async execute(command: CreateUserCommand): Promise<User> {
		const { email, name } = command;
		const user = await this.userRepository.save({ email, name });
		return user;
	}
}
```

### Queries (Read):

```typescript
// get-users.query.ts
export class GetUsersQuery {
	constructor(public readonly limit: number = 10) {}
}

// get-users.handler.ts
import { QueryHandler, IQueryHandler } from "@nestjs/cqrs";

@QueryHandler(GetUsersQuery)
export class GetUsersHandler implements IQueryHandler<GetUsersQuery> {
	constructor(private userRepository: UserRepository) {}

	async execute(query: GetUsersQuery): Promise<User[]> {
		return this.userRepository.find({
			take: query.limit,
		});
	}
}
```

### Events:

```typescript
// user-created.event.ts
export class UserCreatedEvent {
	constructor(
		public readonly userId: string,
		public readonly email: string,
	) {}
}

// user-created.handler.ts (Saga)
import { EventsHandler, IEventHandler } from "@nestjs/cqrs";

@EventsHandler(UserCreatedEvent)
export class UserCreatedHandler implements IEventHandler<UserCreatedEvent> {
	constructor(private emailService: EmailService) {}

	async handle(event: UserCreatedEvent) {
		await this.emailService.sendWelcomeEmail(event.email);
	}
}
```

### Controller এ ব্যবহার:

```typescript
import { CommandBus, QueryBus } from "@nestjs/cqrs";

@Controller("users")
export class UsersController {
	constructor(
		private commandBus: CommandBus,
		private queryBus: QueryBus,
	) {}

	@Post()
	async create(@Body() dto: CreateUserDto) {
		return this.commandBus.execute(new CreateUserCommand(dto.email, dto.name));
	}

	@Get()
	async findAll(@Query("limit") limit: number) {
		return this.queryBus.execute(new GetUsersQuery(limit));
	}
}
```

### Module সেটআপ:

```typescript
import { CqrsModule } from "@nestjs/cqrs";

const CommandHandlers = [CreateUserHandler, UpdateUserHandler];
const QueryHandlers = [GetUsersHandler, GetUserByIdHandler];
const EventHandlers = [UserCreatedHandler];

@Module({
	imports: [CqrsModule],
	controllers: [UsersController],
	providers: [...CommandHandlers, ...QueryHandlers, ...EventHandlers],
})
export class UsersModule {}
```

### Sagas (Complex Event Flows):

```typescript
import { Injectable } from "@nestjs/common";
import { ICommand, ofType, Saga } from "@nestjs/cqrs";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";

@Injectable()
export class UsersSagas {
	@Saga()
	userCreated = (events$: Observable<any>): Observable<ICommand> => {
		return events$.pipe(
			ofType(UserCreatedEvent),
			map((event) => {
				return new SendWelcomeEmailCommand(event.userId, event.email);
			}),
		);
	};
}
```

**সুবিধা:**
- Read/Write operations আলাদা scale করা যায়
- Complex business logic সংগঠিত
- Event sourcing সাপোর্ট
- Testing সহজ

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭০. Event Sourcing

Event Sourcing সব state changes events হিসেবে সংরক্ষণ করে।

### Event Store:

```typescript
@Entity()
export class Event {
	@PrimaryGeneratedColumn("uuid")
	id: string;

	@Column()
	aggregateId: string;

	@Column()
	aggregateType: string;

	@Column()
	eventType: string;

	@Column("jsonb")
	payload: any;

	@Column()
	version: number;

	@CreateDateColumn()
	createdAt: Date;
}
```

### Event Store Service:

```typescript
@Injectable()
export class EventStoreService {
	constructor(
		@InjectRepository(Event)
		private eventRepository: Repository<Event>,
	) {}

	async saveEvent(aggregateId: string, aggregateType: string, eventType: string, payload: any): Promise<void> {
		const lastEvent = await this.eventRepository.findOne({
			where: { aggregateId },
			order: { version: "DESC" },
		});

		const version = lastEvent ? lastEvent.version + 1 : 1;

		await this.eventRepository.save({
			aggregateId,
			aggregateType,
			eventType,
			payload,
			version,
		});
	}

	async getEvents(aggregateId: string): Promise<Event[]> {
		return this.eventRepository.find({
			where: { aggregateId },
			order: { version: "ASC" },
		});
	}

	async getEventsByType(eventType: string): Promise<Event[]> {
		return this.eventRepository.find({
			where: { eventType },
			order: { createdAt: "ASC" },
		});
	}
}
```

### Aggregate Root:

```typescript
export class UserAggregate {
	constructor(
		public readonly id: string,
		private events: any[] = [],
	) {}

	private uncommittedEvents: any[] = [];

	createUser(email: string, name: string) {
		const event = new UserCreatedEvent(this.id, email, name);
		this.apply(event);
		this.uncommittedEvents.push(event);
	}

	updateEmail(newEmail: string) {
		const event = new UserEmailUpdatedEvent(this.id, newEmail);
		this.apply(event);
		this.uncommittedEvents.push(event);
	}

	private apply(event: any) {
		this.events.push(event);

		if (event instanceof UserCreatedEvent) {
			// State update
		} else if (event instanceof UserEmailUpdatedEvent) {
			// State update
		}
	}

	getUncommittedEvents() {
		return this.uncommittedEvents;
	}

	markEventsAsCommitted() {
		this.uncommittedEvents = [];
	}

	static fromEvents(id: string, events: any[]): UserAggregate {
		const aggregate = new UserAggregate(id);
		events.forEach((event) => aggregate.apply(event));
		return aggregate;
	}
}
```

### Command Handler with Event Sourcing:

```typescript
@CommandHandler(CreateUserCommand)
export class CreateUserHandler implements ICommandHandler<CreateUserCommand> {
	constructor(
		private eventStoreService: EventStoreService,
		private eventBus: EventBus,
	) {}

	async execute(command: CreateUserCommand): Promise<string> {
		const userId = uuid();
		const aggregate = new UserAggregate(userId);

		aggregate.createUser(command.email, command.name);

		const events = aggregate.getUncommittedEvents();
		for (const event of events) {
			await this.eventStoreService.saveEvent(userId, "User", event.constructor.name, event);

			this.eventBus.publish(event);
		}

		aggregate.markEventsAsCommitted();

		return userId;
	}
}
```

### Projection (Read Model):

```typescript
@EventsHandler(UserCreatedEvent, UserEmailUpdatedEvent)
export class UserProjectionHandler implements IEventHandler<UserCreatedEvent | UserEmailUpdatedEvent> {
	constructor(
		@InjectRepository(UserReadModel)
		private userReadRepository: Repository<UserReadModel>,
	) {}

	async handle(event: UserCreatedEvent | UserEmailUpdatedEvent) {
		if (event instanceof UserCreatedEvent) {
			await this.userReadRepository.save({
				id: event.userId,
				email: event.email,
				name: event.name,
			});
		} else if (event instanceof UserEmailUpdatedEvent) {
			await this.userReadRepository.update(event.userId, {
				email: event.newEmail,
			});
		}
	}
}
```

**সুবিধা:**
- সম্পূর্ণ audit trail
- Time travel (যেকোনো সময়ের state rebuild)
- Event replay
- Different read models
- Debugging সহজ

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

---

## শেষ কথা

এই ডকুমেন্টে ৭০+ NestJS ইন্টারভিউ প্রশ্ন ও উত্তর রয়েছে যা বিগিনার থেকে ৮+ বছরের অভিজ্ঞ ডেভেলপারদের জন্য উপযোগী।

### প্রধান বিষয়সমূহ যা কভার করা হয়েছে:

✅ **Fundamentals:** Controllers, Providers, Modules, Middleware  
✅ **Advanced Patterns:** Guards, Pipes, Interceptors, Custom Decorators  
✅ **Database:** TypeORM, Mongoose, Migrations, Transactions  
✅ **Authentication:** JWT, Passport, OAuth, Refresh Tokens  
✅ **API Documentation:** Swagger/OpenAPI  
✅ **Deployment:** Docker, Docker Compose, Environment Config  
✅ **Performance:** Caching, Task Scheduling, Rate Limiting  
✅ **Architecture:** CQRS, Event Sourcing, Multi-tenancy  
✅ **Testing:** Jest, Unit Tests, E2E Tests  
✅ **GraphQL:** Resolvers, Mutations, Subscriptions, Scalars  
✅ **WebSockets:** Server-Sent Events, Real-time Communication  
✅ **Microservices:** Inter-service Communication, Message Patterns  

### উপযোগী রিসোর্স:

- [NestJS অফিসিয়াল ডকুমেন্টেশন](https://docs.nestjs.com)
- [NestJS GitHub Repository](https://github.com/nestjs/nest)
- [TypeORM Documentation](https://typeorm.io)
- [Passport.js](http://www.passportjs.org/)

### অবদান:

এই প্রজেক্টে অবদান রাখতে চাইলে:
1. Repository fork করুন
2. নতুন branch তৈরি করুন
3. পরিবর্তন commit করুন
4. Pull request পাঠান

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

---

**© 2026 NestJS Interview Questions - Bangla Version**

> অনুসরণ করুন [@gasangw](https://github.com/gasangw) | মূল Repository: [NestJS-Interview-Questions-And-Answers](https://github.com/gasangw/NestJS-Interview-Questions-And-Answers)


## ৭১. WebSockets এবং Gateways

WebSockets দুই-দিকের real-time communication সক্রিয় করে।

### ইনস্টলেশন:

```bash
npm install @nestjs/websockets @nestjs/platform-socket.io
npm install socket.io
```

### Gateway তৈরি:

```typescript
import {
	WebSocketGateway,
	WebSocketServer,
	SubscribeMessage,
	MessageBody,
	ConnectedSocket,
	OnGatewayInit,
	OnGatewayConnection,
	OnGatewayDisconnect,
} from "@nestjs/websockets";
import { Server, Socket } from "socket.io";

@WebSocketGateway({
	cors: {
		origin: "*",
	},
})
export class ChatGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
	@WebSocketServer()
	server: Server;

	afterInit(server: Server) {
		console.log("WebSocket Gateway initialized");
	}

	handleConnection(client: Socket) {
		console.log(`Client connected: ${client.id}`);
	}

	handleDisconnect(client: Socket) {
		console.log(`Client disconnected: ${client.id}`);
	}

	@SubscribeMessage("message")
	handleMessage(@MessageBody() data: string, @ConnectedSocket() client: Socket): string {
		console.log(`Message from ${client.id}: ${data}`);
		this.server.emit("message", data); // সবাইকে পাঠান
		return "Message received"; // sender কে response
	}

	@SubscribeMessage("joinRoom")
	handleJoinRoom(@MessageBody() room: string, @ConnectedSocket() client: Socket) {
		client.join(room);
		this.server.to(room).emit("userJoined", { userId: client.id });
	}
}
```

### Client-side (Browser):

```javascript
import io from "socket.io-client";

const socket = io("http://localhost:3000");

// সংযোগ হলে
socket.on("connect", () => {
	console.log("Connected:", socket.id);
});

// Message পাঠান
socket.emit("message", "Hello Server!");

// Message গ্রহণ করুন
socket.on("message", (data) => {
	console.log("Received:", data);
});

// Room join
socket.emit("joinRoom", "room1");
```

### Room-based Communication:

```typescript
@WebSocketGateway()
export class ChatGateway {
	@WebSocketServer()
	server: Server;

	@SubscribeMessage("sendToRoom")
	handleRoomMessage(@MessageBody() data: { room: string; message: string }) {
		this.server.to(data.room).emit("message", data.message);
	}

	@SubscribeMessage("broadcast")
	handleBroadcast(@MessageBody() message: string) {
		this.server.emit("message", message); // সবাইকে
	}

	// নির্দিষ্ট client কে
	sendToClient(clientId: string, event: string, data: any) {
		this.server.to(clientId).emit(event, data);
	}
}
```

### Namespace ব্যবহার:

```typescript
@WebSocketGateway({ namespace: "/chat" })
export class ChatGateway {
	// ws://localhost:3000/chat
}

@WebSocketGateway({ namespace: "/admin" })
export class AdminGateway {
	// ws://localhost:3000/admin
}
```

### Authentication সহ:

```typescript
import { UseGuards } from "@nestjs/common";

@WebSocketGateway()
export class ChatGateway {
	@UseGuards(WsAuthGuard)
	@SubscribeMessage("message")
	handleMessage(@ConnectedSocket() client: Socket, @MessageBody() data: string) {
		const user = client.data.user; // Guard থেকে
		return `${user.name} says: ${data}`;
	}
}

// WS Auth Guard
@Injectable()
export class WsAuthGuard implements CanActivate {
	canActivate(context: ExecutionContext): boolean {
		const client = context.switchToWs().getClient<Socket>();
		const token = client.handshake.headers.authorization;

		if (!token) {
			throw new UnauthorizedException();
		}

		const user = this.validateToken(token);
		client.data.user = user;
		return true;
	}

	private validateToken(token: string) {
		// JWT validation
		return { id: 1, name: "User" };
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭২. Microservices - Redis, MQTT, NATS, RabbitMQ, gRPC

### TCP Microservice:

```typescript
// main.ts (Microservice)
import { NestFactory } from "@nestjs/core";
import { Transport, MicroserviceOptions } from "@nestjs/microservices";

async function bootstrap() {
	const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
		transport: Transport.TCP,
		options: {
			host: "localhost",
			port: 8877,
		},
	});
	await app.listen();
}
bootstrap();
```

### Redis Microservice:

```typescript
// redis-microservice
import { Transport } from "@nestjs/microservices";

const app = await NestFactory.createMicroservice(AppModule, {
	transport: Transport.REDIS,
	options: {
		host: "localhost",
		port: 6379,
	},
});
```

### MQTT Microservice:

```typescript
import { Transport } from "@nestjs/microservices";

const app = await NestFactory.createMicroservice(AppModule, {
	transport: Transport.MQTT,
	options: {
		url: "mqtt://localhost:1883",
	},
});
```

### RabbitMQ Microservice:

```bash
npm install amqplib amqp-connection-manager
```

```typescript
import { Transport } from "@nestjs/microservices";

const app = await NestFactory.createMicroservice(AppModule, {
	transport: Transport.RMQ,
	options: {
		urls: ["amqp://localhost:5672"],
		queue: "cats_queue",
		queueOptions: {
			durable: false,
		},
	},
});
```

### gRPC Microservice:

```bash
npm install @grpc/grpc-js @grpc/proto-loader
```

```typescript
// main.ts
import { Transport } from "@nestjs/microservices";
import { join } from "path";

const app = await NestFactory.createMicroservice(AppModule, {
	transport: Transport.GRPC,
	options: {
		package: "hero",
		protoPath: join(__dirname, "./hero.proto"),
	},
});
```

```proto
// hero.proto
syntax = "proto3";

package hero;

service HeroService {
  rpc FindOne (HeroById) returns (Hero) {}
}

message HeroById {
  int32 id = 1;
}

message Hero {
  int32 id = 1;
  string name = 2;
}
```

### Message Patterns:

```typescript
import { Controller } from "@nestjs/common";
import { MessagePattern, EventPattern } from "@nestjs/microservices";

@Controller()
export class MathController {
	@MessagePattern({ cmd: "sum" }) // Request-response
	accumulate(data: number[]): number {
		return data.reduce((a, b) => a + b);
	}

	@EventPattern("user_created") // Event-based
	async handleUserCreated(data: Record<string, unknown>) {
		console.log("User created:", data);
	}
}
```

### Client থেকে Microservice Call:

```typescript
import { Injectable } from "@nestjs/common";
import { ClientProxy, ClientProxyFactory, Transport } from "@nestjs/microservices";

@Injectable()
export class AppService {
	private client: ClientProxy;

	constructor() {
		this.client = ClientProxyFactory.create({
			transport: Transport.TCP,
			options: {
				host: "localhost",
				port: 8877,
			},
		});
	}

	async callMicroservice() {
		const pattern = { cmd: "sum" };
		const data = [1, 2, 3, 4, 5];

		return this.client.send(pattern, data).toPromise();
	}

	emitEvent() {
		this.client.emit("user_created", { id: 1, name: "John" });
	}
}
```

### Hybrid Application (HTTP + Microservice):

```typescript
// main.ts
async function bootstrap() {
	const app = await NestFactory.create(AppModule);

	// Microservice connection যোগ করুন
	app.connectMicroservice({
		transport: Transport.TCP,
		options: { port: 8877 },
	});

	await app.startAllMicroservices();
	await app.listen(3000); // HTTP server
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭৩. Custom Decorators তৈরি

Custom decorators আপনার নিজস্ব logic encapsulate করতে দেয়।

### Parameter Decorator:

```typescript
import { createParamDecorator, ExecutionContext } from "@nestjs/common";

export const User = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
	const request = ctx.switchToHttp().getRequest();
	return request.user;
});

// ব্যবহার
@Get("profile")
getProfile(@User() user: UserEntity) {
  return user;
}
```

### Specific Data Extract:

```typescript
export const UserId = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
	const request = ctx.switchToHttp().getRequest();
	return request.user?.id;
});

// ব্যবহার
@Get("posts")
getUserPosts(@UserId() userId: number) {
  return this.postsService.findByUser(userId);
}
```

### Data Passing to Decorator:

```typescript
export const User = createParamDecorator((data: string, ctx: ExecutionContext) => {
	const request = ctx.switchToHttp().getRequest();
	const user = request.user;

	return data ? user?.[data] : user;
});

// ব্যবহার
@Get()
findAll(@User("email") userEmail: string) {
  return `User email: ${userEmail}`;
}
```

### Method Decorator (Roles):

```typescript
import { SetMetadata } from "@nestjs/common";

export const ROLES_KEY = "roles";
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);

// ব্যবহার
@Post()
@Roles("admin", "moderator")
create(@Body() dto: CreateDto) {
  return this.service.create(dto);
}
```

### Combined Decorator:

```typescript
import { applyDecorators } from "@nestjs/common";

export function Auth(...roles: string[]) {
	return applyDecorators(
		UseGuards(JwtAuthGuard, RolesGuard),
		ApiBearerAuth(),
		ApiUnauthorizedResponse({ description: "Unauthorized" }),
		Roles(...roles),
	);
}

// ব্যবহার
@Post()
@Auth("admin")
create(@Body() dto: CreateDto) {
  return this.service.create(dto);
}
```

### Class Decorator:

```typescript
export function Controller(prefix: string): ClassDecorator {
	return (target: Function) => {
		Reflect.defineMetadata("path", prefix, target);
	};
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭৪. Validation Techniques (class-validator বিস্তারিত)

### class-validator ইনস্টলেশন:

```bash
npm install class-validator class-transformer
```

### সব Validation Decorators:

```typescript
import {
	IsString,
	IsInt,
	IsEmail,
	IsNotEmpty,
	IsOptional,
	MinLength,
	MaxLength,
	Min,
	Max,
	IsArray,
	IsEnum,
	IsBoolean,
	IsDate,
	IsUrl,
	IsUUID,
	Matches,
	IsPhoneNumber,
	IsPostalCode,
	IsCreditCard,
	IsISO8601,
	ArrayMinSize,
	ArrayMaxSize,
	ValidateNested,
	IsNumber,
	IsPositive,
	IsNegative,
	IsDivisibleBy,
} from "class-validator";
import { Type } from "class-transformer";

export class CreateUserDto {
	@IsNotEmpty({ message: "নাম খালি হতে পারবে না" })
	@IsString()
	@MinLength(2, { message: "নাম কমপক্ষে 2 অক্ষরের হতে হবে" })
	@MaxLength(50)
	name: string;

	@IsEmail({}, { message: "বৈধ ইমেইল দিন" })
	email: string;

	@IsInt()
	@Min(18, { message: "বয়স কমপক্ষে 18 হতে হবে" })
	@Max(100)
	age: number;

	@IsOptional() // Optional field
	@IsString()
	bio?: string;

	@IsArray()
	@ArrayMinSize(1)
	@IsString({ each: true })
	tags: string[];

	@IsEnum(["admin", "user", "guest"])
	role: string;

	@IsBoolean()
	isActive: boolean;

	@IsDate()
	@Type(() => Date)
	birthDate: Date;

	@IsUrl()
	website: string;

	@IsUUID()
	referralCode: string;

	@Matches(/^[A-Z0-9]*$/, { message: "শুধুমাত্র uppercase letters এবং numbers" })
	code: string;

	@IsPhoneNumber("BD")
	phoneNumber: string;

	@IsPostalCode("BD")
	postalCode: string;

	@IsCreditCard()
	cardNumber: string;

	@IsISO8601()
	timestamp: string;
}
```

### Nested Validation:

```typescript
class AddressDto {
	@IsString()
	street: string;

	@IsString()
	city: string;

	@IsPostalCode("BD")
	postalCode: string;
}

export class CreateUserDto {
	@IsString()
	name: string;

	@ValidateNested()
	@Type(() => AddressDto)
	address: AddressDto;

	@ValidateNested({ each: true })
	@Type(() => AddressDto)
	@IsArray()
	addresses: AddressDto[];
}
```

### Custom Validator:

```typescript
import { registerDecorator, ValidationOptions, ValidationArguments } from "class-validator";

export function IsUserAlreadyExist(validationOptions?: ValidationOptions) {
	return function (object: Object, propertyName: string) {
		registerDecorator({
			name: "isUserAlreadyExist",
			target: object.constructor,
			propertyName: propertyName,
			options: validationOptions,
			validator: {
				async validate(value: any, args: ValidationArguments) {
					// Database check
					const userExists = await checkUserExists(value);
					return !userExists;
				},
				defaultMessage(args: ValidationArguments) {
					return "ইউজার ইতিমধ্যে বিদ্যমান";
				},
			},
		});
	};
}

// ব্যবহার
export class CreateUserDto {
	@IsEmail()
	@IsUserAlreadyExist()
	email: string;
}
```

### Conditional Validation:

```typescript
import { ValidateIf } from "class-validator";

export class CreateShipmentDto {
	@IsString()
	recipientName: string;

	@ValidateIf((o) => o.shipmentType === "international")
	@IsString()
	customsDeclaration?: string;

	@IsEnum(["domestic", "international"])
	shipmentType: string;
}
```

### ValidationPipe Configuration:

```typescript
app.useGlobalPipes(
	new ValidationPipe({
		whitelist: true, // Extra properties remove
		forbidNonWhitelisted: true, // Extra properties থাকলে error
		transform: true, // Auto type transformation
		transformOptions: {
			enableImplicitConversion: true,
		},
		disableErrorMessages: false, // Production এ true
		validationError: {
			target: false,
			value: false,
		},
	}),
);
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭৫. Performance Optimization (Fastify)

Fastify Express এর চেয়ে দ্রুত এবং কম memory ব্যবহার করে।

### Fastify সেটআপ:

```bash
npm install @nestjs/platform-fastify
```

```typescript
import { NestFactory } from "@nestjs/core";
import { FastifyAdapter, NestFastifyApplication } from "@nestjs/platform-fastify";
import { AppModule } from "./app.module";

async function bootstrap() {
	const app = await NestFactory.create<NestFastifyApplication>(AppModule, new FastifyAdapter());
	await app.listen(3000, "0.0.0.0");
}
bootstrap();
```

### Fastify Plugins:

```typescript
import fastifyHelmet from "@fastify/helmet";
import fastifyRateLimit from "@fastify/rate-limit";
import fastifyCompress from "@fastify/compress";

async function bootstrap() {
	const app = await NestFactory.create<NestFastifyApplication>(AppModule, new FastifyAdapter());

	await app.register(fastifyHelmet);
	await app.register(fastifyRateLimit, {
		max: 100,
		timeWindow: "1 minute",
	});
	await app.register(fastifyCompress);

	await app.listen(3000);
}
```

### Response Serialization:

```typescript
import { Controller, Get } from "@nestjs/common";

@Controller("users")
export class UsersController {
	@Get()
	findAll() {
		return {
			data: [],
			meta: { total: 0 },
		};
	}
}
```

### Performance তুলনা:

| Feature | Express | Fastify |
|---------|---------|---------|
| গতি | Medium | Fast (~2x) |
| Memory | Higher | Lower |
| Overhead | Higher | Lower |
| Ecosystem | Mature | Growing |

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭৬. Compression

HTTP response compress করে bandwidth সাশ্রয় করে।

### ইনস্টলেশন (Express):

```bash
npm install compression
```

```typescript
import * as compression from "compression";

async function bootstrap() {
	const app = await NestFactory.create(AppModule);
	app.use(compression());
	await app.listen(3000);
}
```

### Fastify Compression:

```typescript
import fastifyCompress from "@fastify/compress";

await app.register(fastifyCompress, {
	encodings: ["gzip", "deflate"],
});
```

### Selective Compression:

```typescript
app.use(
	compression({
		filter: (req, res) => {
			if (req.headers["x-no-compression"]) {
				return false;
			}
			return compression.filter(req, res);
		},
		threshold: 1024, // 1KB এর চেয়ে বড় হলে compress
	}),
);
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭৭. HTTP Module এবং External API Calls

### HttpModule ব্যবহার:

```bash
npm install @nestjs/axios axios
```

```typescript
import { HttpModule } from "@nestjs/axios";

@Module({
	imports: [HttpModule],
	providers: [ApiService],
})
export class ApiModule {}
```

### HTTP Service:

```typescript
import { Injectable } from "@nestjs/common";
import { HttpService } from "@nestjs/axios";
import { firstValueFrom } from "rxjs";
import { map } from "rxjs/operators";

@Injectable()
export class ApiService {
	constructor(private httpService: HttpService) {}

	async getUsers(): Promise<any> {
		const { data } = await firstValueFrom(this.httpService.get("https://jsonplaceholder.typicode.com/users"));
		return data;
	}

	async createUser(userData: any): Promise<any> {
		return firstValueFrom(
			this.httpService
				.post("https://api.example.com/users", userData, {
					headers: {
						Authorization: "Bearer token",
					},
				})
				.pipe(map((response) => response.data)),
		);
	}
}
```

### Retry Logic:

```typescript
import { retry, catchError } from "rxjs/operators";
import { throwError } from "rxjs";

async getUsersWithRetry(): Promise<any> {
  return firstValueFrom(
    this.httpService.get('https://api.example.com/users').pipe(
      retry(3), // 3 বার পুনরায় চেষ্টা
      catchError(error => {
        console.error('Error:', error);
        return throwError(() => new Error('API call failed'));
      })
    )
  );
}
```

### Configuration:

```typescript
HttpModule.register({
	timeout: 5000,
	maxRedirects: 5,
	headers: {
		"User-Agent": "NestJS App",
	},
});
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭৮. Model-View-Controller (MVC) Pattern

NestJS MVC architecture সমর্থন করে template rendering এর জন্য।

### Handlebars সেটআপ:

```bash
npm install hbs
```

```typescript
import { NestFactory } from "@nestjs/core";
import { NestExpressApplication } from "@nestjs/platform-express";
import { join } from "path";

async function bootstrap() {
	const app = await NestFactory.create<NestExpressApplication>(AppModule);

	app.useStaticAssets(join(__dirname, "..", "public"));
	app.setBaseViewsDir(join(__dirname, "..", "views"));
	app.setViewEngine("hbs");

	await app.listen(3000);
}
bootstrap();
```

### Controller with Views:

```typescript
import { Controller, Get, Render } from "@nestjs/common";

@Controller()
export class AppController {
	@Get()
	@Render("index")
	root() {
		return { message: "Hello world!", title: "NestJS MVC" };
	}

	@Get("users")
	@Render("users")
	async getUsers() {
		const users = await this.usersService.findAll();
		return { users };
	}
}
```

### Template (views/index.hbs):

```handlebars
<!DOCTYPE html>
<html>
<head>
  <title>{{title}}</title>
</head>
<body>
  <h1>{{message}}</h1>
</body>
</html>
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৭৯. Hot Reload (Webpack HMR)

Development এ fast iteration এর জন্য Hot Module Replacement।

### Webpack HMR সেটআপ:

```bash
npm install webpack-node-externals run-script-webpack-plugin webpack
```

### webpack.config.js:

```javascript
const webpack = require("webpack");
const nodeExternals = require("webpack-node-externals");
const { RunScriptWebpackPlugin } = require("run-script-webpack-plugin");

module.exports = function (options, webpack) {
	return {
		...options,
		entry: ["webpack/hot/poll?100", options.entry],
		externals: [
			nodeExternals({
				allowlist: ["webpack/hot/poll?100"],
			}),
		],
		plugins: [
			...options.plugins,
			new webpack.HotModuleReplacementPlugin(),
			new webpack.WatchIgnorePlugin({
				paths: [/\.js$/, /\.d\.ts$/],
			}),
			new RunScriptWebpackPlugin({ name: options.output.filename, autoRestart: false }),
		],
	};
};
```

### main.ts এ HMR:

```typescript
declare const module: any;

async function bootstrap() {
	const app = await NestFactory.create(AppModule);
	await app.listen(3000);

	if (module.hot) {
		module.hot.accept();
		module.hot.dispose(() => app.close());
	}
}
bootstrap();
```

### package.json scripts:

```json
{
	"scripts": {
		"start:dev": "nest build --webpack --webpackPath webpack.config.js --watch"
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮০. Platform Agnosticism

NestJS বিভিন্ন HTTP platform এ চলতে পারে।

### Express (ডিফল্ট):

```typescript
import { NestFactory } from "@nestjs/core";

const app = await NestFactory.create(AppModule);
```

### Fastify:

```typescript
import { FastifyAdapter } from "@nestjs/platform-fastify";

const app = await NestFactory.create(AppModule, new FastifyAdapter());
```

### Platform-specific Code:

```typescript
import { Controller, Get, Req, Res } from "@nestjs/common";
import { Request, Response } from "express";

@Controller()
export class AppController {
	// Express specific
	@Get("express")
	getExpress(@Req() req: Request, @Res() res: Response) {
		res.send("Express");
	}
}
```

### Platform-agnostic Code (প্রস্তাবিত):

```typescript
@Controller()
export class AppController {
	@Get()
	getData() {
		return { message: "Platform independent" };
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## অতিরিক্ত বিষয়সমূহ

## ৮১. Lifecycle Events

NestJS বিভিন্ন lifecycle hooks প্রদান করে:

```typescript
import { Injectable, OnModuleInit, OnModuleDestroy, OnApplicationBootstrap, OnApplicationShutdown } from "@nestjs/common";

@Injectable()
export class UsersService implements OnModuleInit, OnModuleDestroy, OnApplicationBootstrap, OnApplicationShutdown {
	onModuleInit() {
		console.log("Module initialized");
	}

	onApplicationBootstrap() {
		console.log("Application bootstrap complete");
	}

	onModuleDestroy() {
		console.log("Module destroyed");
	}

	async onApplicationShutdown(signal?: string) {
		console.log(`Application shutting down (${signal})`);
		// Cleanup logic
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮২. Testing Strategies (Unit & E2E)

### Unit Testing:

```typescript
import { Test, TestingModule } from "@nestjs/testing";
import { UsersService } from "./users.service";

describe("UsersService", () => {
	let service: UsersService;
	let mockRepository: any;

	beforeEach(async () => {
		mockRepository = {
			find: jest.fn(),
			findOne: jest.fn(),
			save: jest.fn(),
		};

		const module: TestingModule = await Test.createTestingModule({
			providers: [
				UsersService,
				{
					provide: "UserRepository",
					useValue: mockRepository,
				},
			],
		}).compile();

		service = module.get<UsersService>(UsersService);
	});

	it("should be defined", () => {
		expect(service).toBeDefined();
	});

	it("should return all users", async () => {
		const users = [{ id: 1, name: "Test" }];
		mockRepository.find.mockResolvedValue(users);

		const result = await service.findAll();

		expect(result).toEqual(users);
		expect(mockRepository.find).toHaveBeenCalled();
	});
});
```

### E2E Testing:

```typescript
import { Test, TestingModule } from "@nestjs/testing";
import { INestApplication } from "@nestjs/common";
import * as request from "supertest";
import { AppModule } from "./../src/app.module";

describe("AppController (e2e)", () => {
	let app: INestApplication;

	beforeEach(async () => {
		const moduleFixture: TestingModule = await Test.createTestingModule({
			imports: [AppModule],
		}).compile();

		app = moduleFixture.createNestApplication();
		await app.init();
	});

	it("/ (GET)", () => {
		return request(app.getHttpServer()).get("/").expect(200).expect("Hello World!");
	});

	it("/users (POST)", () => {
		return request(app.getHttpServer())
			.post("/users")
			.send({ name: "Test", email: "test@example.com" })
			.expect(201)
			.expect((res) => {
				expect(res.body).toHaveProperty("id");
			});
	});

	afterAll(async () => {
		await app.close();
	});
});
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮৩. CLI Usage এবং Generators

### NestJS CLI Commands:

```bash
# নতুন application
nest new my-app

# Generate resources
nest generate controller users
nest generate service users
nest generate module users
nest generate guard auth
nest generate interceptor logging
nest generate pipe validation
nest generate filter http-exception
nest generate middleware logger
nest generate decorator current-user

# Resource তৈরি (সব একসাথে)
nest generate resource users

# Shorthand
nest g co users
nest g s users
nest g mo users

# Dry run (preview)
nest g s users --dry-run

# Skip tests
nest g s users --no-spec

# Flat structure
nest g s users --flat

# Specific path
nest g s users --path src/modules/users
```

### Project Information:

```bash
nest info

# Output:
# [System Information]
# OS Version     : macOS
# NodeJS Version : v18.0.0
# NPM Version    : 8.0.0
# [Nest CLI]
# Nest CLI Version : 9.0.0
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮৪. Global Path Prefix

সব routes এর জন্য common prefix।

```typescript
async function bootstrap() {
	const app = await NestFactory.create(AppModule);

	app.setGlobalPrefix("api/v1");
	// এখন সব routes: /api/v1/users, /api/v1/posts, etc.

	// নির্দিষ্ট routes বাদ দিতে
	app.setGlobalPrefix("api/v1", {
		exclude: ["health", "metrics"],
	});

	await app.listen(3000);
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮৫. HTTPS এবং Multiple Servers

### HTTPS সেটআপ:

```typescript
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import * as fs from "fs";

async function bootstrap() {
	const httpsOptions = {
		key: fs.readFileSync("./secrets/private-key.pem"),
		cert: fs.readFileSync("./secrets/public-certificate.pem"),
	};

	const app = await NestFactory.create(AppModule, {
		httpsOptions,
	});

	await app.listen(443);
}
bootstrap();
```

### HTTP এবং HTTPS একসাথে:

```typescript
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import * as fs from "fs";
import * as http from "http";
import * as https from "https";
import { ExpressAdapter } from "@nestjs/platform-express";
import * as express from "express";

async function bootstrap() {
	const server = express();
	const app = await NestFactory.create(AppModule, new ExpressAdapter(server));

	await app.init();

	// HTTP server
	http.createServer(server).listen(3000);

	// HTTPS server
	https
		.createServer(
			{
				key: fs.readFileSync("./secrets/private-key.pem"),
				cert: fs.readFileSync("./secrets/certificate.pem"),
			},
			server,
		)
		.listen(443);

	console.log("HTTP: 3000, HTTPS: 443");
}
bootstrap();
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮৬. Logger Advanced Usage

### Custom Logger:

```typescript
import { LoggerService } from "@nestjs/common";

export class MyLogger implements LoggerService {
	log(message: string) {
		console.log(`[LOG] ${message}`);
	}

	error(message: string, trace: string) {
		console.error(`[ERROR] ${message}`, trace);
	}

	warn(message: string) {
		console.warn(`[WARN] ${message}`);
	}

	debug(message: string) {
		console.debug(`[DEBUG] ${message}`);
	}

	verbose(message: string) {
		console.log(`[VERBOSE] ${message}`);
	}
}

// ব্যবহার
const app = await NestFactory.create(AppModule, {
	logger: new MyLogger(),
});
```

### Winston Logger Integration:

```bash
npm install nest-winston winston
```

```typescript
import { WinstonModule } from "nest-winston";
import * as winston from "winston";

@Module({
	imports: [
		WinstonModule.forRoot({
			transports: [
				new winston.transports.Console({
					format: winston.format.combine(winston.format.timestamp(), winston.format.colorize(), winston.format.printf(({ timestamp, level, message }) => {
						return `${timestamp} [${level}]: ${message}`;
					})),
				}),
				new winston.transports.File({
					filename: "logs/error.log",
					level: "error",
				}),
				new winston.transports.File({
					filename: "logs/combined.log",
				}),
			],
		}),
	],
})
export class AppModule {}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮৭. Health Checks

Application health monitoring এর জন্য।

```bash
npm install @nestjs/terminus
```

```typescript
import { Controller, Get } from "@nestjs/common";
import { HealthCheck, HealthCheckService, HttpHealthIndicator, TypeOrmHealthIndicator } from "@nestjs/terminus";

@Controller("health")
export class HealthController {
	constructor(
		private health: HealthCheckService,
		private http: HttpHealthIndicator,
		private db: TypeOrmHealthIndicator,
	) {}

	@Get()
	@HealthCheck()
	check() {
		return this.health.check([
			() => this.http.pingCheck("nestjs-docs", "https://docs.nestjs.com"),
			() => this.db.pingCheck("database"),
		]);
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

## ৮৮. Queue এবং Background Jobs (Bull)

```bash
npm install @nestjs/bull bull
npm install @types/bull
```

```typescript
import { BullModule } from "@nestjs/bull";

@Module({
	imports: [
		BullModule.forRoot({
			redis: {
				host: "localhost",
				port: 6379,
			},
		}),
		BullModule.registerQueue({
			name: "emails",
		}),
	],
})
export class AppModule {}
```

### Producer:

```typescript
import { Injectable } from "@nestjs/common";
import { InjectQueue } from "@nestjs/bull";
import { Queue } from "bull";

@Injectable()
export class EmailService {
	constructor(@InjectQueue("emails") private emailQueue: Queue) {}

	async sendWelcomeEmail(email: string) {
		await this.emailQueue.add(
			"welcome",
			{
				email,
				subject: "Welcome!",
			},
			{
				delay: 5000, // 5 seconds delay
				attempts: 3, // retry 3 times
			},
		);
	}
}
```

### Consumer:

```typescript
import { Processor, Process } from "@nestjs/bull";
import { Job } from "bull";

@Processor("emails")
export class EmailProcessor {
	@Process("welcome")
	async handleWelcomeEmail(job: Job) {
		console.log("Sending email to:", job.data.email);
		// Email পাঠানোর logic
		await this.sendEmail(job.data);
		return { sent: true };
	}

	@Process()
	async handleAllJobs(job: Job) {
		console.log("Processing job:", job.name);
	}

	private async sendEmail(data: any) {
		// Implementation
	}
}
```

**[⬆ সূচিপত্রে ফিরে যান](#সূচিপত্র)**

---

## 📚 সম্পূর্ণ Topics কভার তালিকা

### ✅ Overview
- [x] First steps
- [x] Controllers  
- [x] Providers
- [x] Modules
- [x] Middleware
- [x] Exception filters
- [x] Pipes
- [x] Guards
- [x] Interceptors
- [x] Custom decorators

### ✅ Fundamentals
- [x] Custom providers (useClass, useValue, useFactory, useExisting)
- [x] Asynchronous providers
- [x] Circular dependency
- [x] Platform agnosticism
- [x] Testing

### ✅ Techniques
- [x] Authentication (JWT, Passport, OAuth)
- [x] Database (TypeORM, Mongoose, Prisma)
- [x] Mongo
- [x] File upload (Multer, S3)
- [x] Validation (class-validator)
- [x] Caching (Redis)
- [x] Serialization
- [x] Logger (Custom, Winston)
- [x] Security (Helmet, CSRF, Rate Limiting)
- [x] Configuration (Environment Variables)
- [x] Compression
- [x] HTTP module
- [x] Model-View-Controller
- [x] Performance (Fastify)
- [x] Hot reload (Webpack)

### ✅ GraphQL
- [x] Quick start
- [x] Resolvers
- [x] Mutations
- [x] Subscriptions
- [x] Scalars
- [x] Tooling

### ✅ WebSockets
- [x] Gateways
- [x] Exception filters
- [x] Pipes
- [x] Guards
- [x] Interceptors
- [x] Adapters

### ✅ Microservices
- [x] Basics
- [x] Redis
- [x] MQTT
- [x] NATS
- [x] RabbitMQ
- [x] gRPC
- [x] Exception filters
- [x] Pipes
- [x] Guards
- [x] Interceptors

### ✅ Execution Context
- [x] বিস্তারিত ব্যবহার

### ✅ Recipes
- [x] TypeORM (Migrations, Transactions, Soft Delete)
- [x] Mongoose
- [x] Sequelize
- [x] CQRS
- [x] OpenAPI (Swagger)
- [x] Prisma

### ✅ CLI
- [x] Overview
- [x] Usage
- [x] Generators

### ✅ FAQ
- [x] Express instance
- [x] Global path prefix
- [x] Lifecycle events
- [x] Hybrid application
- [x] HTTPS & multiple servers
- [x] Examples

### ✅ Advanced Patterns (8+ Years)
- [x] Multi-tenancy
- [x] Event Sourcing
- [x] CQRS
- [x] Dynamic Modules
- [x] Scoped Providers
- [x] Hierarchical Injector
- [x] Optional Providers
- [x] Property vs Constructor Injection

### ✅ Performance & Optimization
- [x] Caching strategies
- [x] Task scheduling
- [x] Queue (Bull)
- [x] Compression
- [x] Health checks

---

## 🎯 সর্বমোট Content:

- **প্রশ্ন সংখ্যা:** 88+
- **লাইন সংখ্যা:** 5,262+
- **কোড উদাহরণ:** 200+
- **Topics কভার:** সব NestJS v5 documentation
- **অভিজ্ঞতা লেভেল:** Beginner থেকে 8+ years Expert
- **ভাষা:** সম্পূর্ণ বাংলা

---

## 📖 Reference Links

### Official Documentation:
- [NestJS Official Docs](https://docs.nestjs.com)
- [NestJS v5 Docs](https://docs.nestjs.com/v5/)
- [TypeORM](https://typeorm.io)
- [Mongoose](https://mongoosejs.com)
- [Prisma](https://www.prisma.io)
- [Passport.js](http://www.passportjs.org/)

### Community Resources:
- [NestJS GitHub](https://github.com/nestjs/nest)
- [NestJS Discord](https://discord.gg/nestjs)
- [Original Repository](https://github.com/gasangw/NestJS-Interview-Questions-And-Answers)

### Tools & Libraries:
- [class-validator](https://github.com/typestack/class-validator)
- [class-transformer](https://github.com/typestack/class-transformer)
- [Socket.io](https://socket.io)
- [Bull Queue](https://github.com/OptimalBits/bull)
- [Jest](https://jestjs.io)

---

## 🙏 কৃতজ্ঞতা

এই সম্পূর্ণ NestJS Interview Questions সংগ্রহটি তৈরিতে সহায়তার জন্য:
- [@gasangw](https://github.com/gasangw) - মূল ইংরেজি repository এর জন্য
- NestJS Community - Documentation এবং best practices এর জন্য
- সব Contributors যারা open source community তে অবদান রাখেন

---

## 📝 সর্বশেষ আপডেট

**Version:** 2.0  
**Last Updated:** জানুয়ারি ৩, ২০২৬  
**Total Questions:** 88+  
**Status:** ✅ সম্পূর্ণ  

**Changes:**
- ✅ সব 70 মৌলিক প্রশ্ন যুক্ত
- ✅ 18+ উন্নত বিষয় (৮ বছর+)
- ✅ WebSockets, Microservices, GraphQL
- ✅ Performance, Testing, CLI
- ✅ সব NestJS v5 topics কভার
- ✅ Real-world কোড উদাহরণ

---

**⭐ এই repository পছন্দ হলে Star দিন!**

**🔗 Share করুন:** যদি এই resource উপকারী মনে হয়, অন্যদের সাথে share করুন।

**💬 Feedback:** কোন প্রশ্ন বা পরামর্শ থাকলে issue তৈরি করুন।

---

**© 2026 NestJS Interview Questions - Complete Bangla Version**

> Follow [@gasangw](https://github.com/gasangw) | [Original Repo](https://github.com/gasangw/NestJS-Interview-Questions-And-Answers)

**সফল ইন্টারভিউর জন্য শুভকামনা! 🚀**

